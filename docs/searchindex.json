{"categories":[],"posts":[{"content":"開始使用 上次更換了一下 Blog 的 hugo theme，但是後來發現直接用 git clone 下載下來的 theme 沒有更新到 GitHub 上面 (╯•̀ὤ•́)╯。\n歐給歐給，我們改用一下 Submodule 處理一下\n加入 Submodule 這次目標要把從 Gitee 上 Clone 回來的 Repo XiaoXiaoSN/hugo-theme-pure 作為 Theme， 放到 XiaoXiaoSN/XiaoXiaoBlog 的 themes/pure 資料夾下！\ngit rm themes/pure git submodule add git@github.com:XiaoXiaoSN/hugo-theme-pure.git themes/pure  完成後我們會多一個 .gitmodules 檔案，裡面的內容也很直觀\n[submodule \u0026quot;themes/pure\u0026quot;] path = themes/pure url = git@github.com:XiaoXiaoSN/hugo-theme-pure.git  把更新推出去～ git push origin master 第一次使用 Submodule 的話 為了測試我再另外下載一份\ngit clone --depth 1 git@github.com:XiaoXiaoSN/XiaoXiaoBlog.git testXiaoXiaoBlog  進去後我們可以用 git submodule 查看目前的狀態\n$ git submodule c97723a02ac3abace65a6433eab381f0acbe2719 themes/pure  $ git submodule init 子模組 'themes/pure'（git@github.com:XiaoXiaoSN/hugo-theme-pure.git）已對路徑 'themes/pure' 註冊 $ git submodule update 正複製到 '/Users/arios/Project/XiaoXiaoBlog/themes/pure'... 子模組路徑 'themes/pure'：簽出 'c97723a02ac3abace65a6433eab381f0acbe2719'  或是也可以合在一起做\ngit submodule update --init  更新 Submodule 要測試更新 Submodule 所以我們先到被註冊的 Submodule 製造一個 Commit 模擬依賴的模組被更新的狀態～\n# cd hugo-theme-pure git commit -m 'chore: just a empty commit' --allow-empty  再來我們回到剛剛的專案內，並且 cd 到 Submodule 的資料夾\n# cd themes/pure $ git pull origin master 來自 github.com:XiaoXiaoSN/hugo-theme-pure * branch master -\u0026gt; FETCH_HEAD 更新 c97723a..afa94b2 Fast-forward  回到這邊發現 Submodule 已經更新了\n# cd ../.. $ git submodule +afa94b26c59df0c4ce226f173d88fdc8ba9a0246 themes/pure (heads/master)  再重新推出去就好囉～～\ngit add --all git commit -m 'feat: upgrade `themes/pure`' git push origin master  看那個 Commit Hash 是不是不一樣了呀 \u0026gt;u\u0026lt; Ref https://blog.wu-boy.com/2011/09/introduction-to-git-submodule/\n","id":0,"section":"posts","summary":"開始使用 上次更換了一下 Blog 的 hugo theme，但是後來發現直接用 git clone 下載下來的 theme 沒有更新到 GitHub 上面 (╯•̀ὤ•́)╯。 歐給歐給，我們改用一下 Submodule 處理一","tags":["git","hugo"],"title":"用一下 Git Submodule 啦","uri":"https://blog.10oz.tw/20220124-use-git-submodule/","year":"2022"},{"content":"Linux DE Linux 的 Desktop Environments 真的多到不可思議啦，怎麼選怎麼玩咧\nKDE Plasma 5 大家熟知的一個輕量 DE，有現代且優雅的介面和高度可自訂的優點。 不過也由於高度自訂的關係導致上手難度會相對提高！\n預設安裝 Plasma 的有 openSUSE、Kubuntu 和 KDE Neon，當然作為熱門 DE 常見的 Linux 發行版也其安裝教學\nGNOME 真正的大佬來了，做為最多 Linux 發行版（和多數的 BSD 系統）預設的 DE，更有許多的 DE 都是基於他修改來的。 缺點是大家都說他胖 QQ，如果要選擇安裝在輕量型機器上時可能不是首選\n Ubuntu 目前也是使用 GNOME 作為其預設 DE\n Xfce 具有超輕量、低耗、穩定等優點，也是目前 linux 發行版常見的預設 DE，雖然較沒有高級的功能設定但是在性能優先的環境下可以考慮使用 Xfce\n 知名預設 DE 為 Xfce 的有 kali linux官方也有教你轉 KDE) 以及 Xubuntu\n LXDE \u0026amp;\u0026amp; LXQt 輕量型的 DE，從名字不難看出是由 Qt 開發的，從過去的 LXDE 移植到 Qt 後輕量化了不少！ 然後 LXQt 作者是個台灣人喔xDDD\n Raspberry Pi OS 使用的 DE PIXEL 是由 LXDE 修改而來\n Pantheon Like macOS 設計的 DE，基於 GNOME 開發而來。 我個人使用時間最長的環境，直到我用惹真正的 macOS 才發現他根本不行嘛 xDDD 不過也是好幾年以前的事情了，他持續有在更新可以再多看一下～～\n elementary OS 預設 DE\n Unity 這是我最早接觸到的一個 DE，也是早期 Ubuntu 的預設介面（Ubuntu 17.04是最後一個預載 Unity 桌面環境的版本） 它也是由 GNOME 修改而來。 Ref https://itsfoss.com/best-linux-desktop-environments/ https://github.com/twtrubiks/linux-note/tree/master/linux-de\n","id":1,"section":"posts","summary":"Linux DE Linux 的 Desktop Environments 真的多到不可思議啦，怎麼選怎麼玩咧 KDE Plasma 5 大家熟知的一個輕量 DE，有現代且優雅的介面和高度可自訂的優點。 不過也由於高度自訂的關係導","tags":["linux","de"],"title":"認識一次常見 Linux GUI (Desktop Environments)","uri":"https://blog.10oz.tw/20210706-known-popular-linux-de/","year":"2021"},{"content":"你問阿狗是什麼 GitOps + Kubernetes 的產物，相當不錯的運維工具\n先來裝 Argo CD 我們要用 helm 安裝裝起來喔\nhelm repo add argo-cd https://argoproj.github.io/argo-helm helm repo update  來準備個 values.yaml\ninstallCRDs: false global: image: tag: v1.8.6 dex: enabled: false server: extraArgs: - --insecure # 如果說你有需要用反向代理抓 subpath，可以在這裡設定 # - --basehref=/argo # - --rootpath=/argo config: # 這裡要把你要監看的 git repo 放上來， # 範例是私有 Gitlab 的設定方式 repositories: | - name: dev-argo insecure: true insecureIgnoreHostKey: true sshPrivateKeySecret: name: argocd-secret key: webhook.gitlab.secret type: git url: git@gitlab.10oz.tw:self_group/dev-argo.git metrics: enabled: true configs: secret: # 這裡產生一個 ssh key 來設定 gitlab repo 裡面的 deploy key # 然後把相應的 private 提供給 Argo 使用 gitlabSecret: |- first set ssh-public-key in gitlab repo, Settings \u0026gt; Repository \u0026gt; Deploy Keys and replace the field with ssh-private-key   PS: 後面有說這裏的 Repository 跟 Secret 在哪裡弄 :) 反正先裝等等還能改 XDD\n 下個安裝指令\nhelm install argo-cd argo-cd/argo-cd --version 2.11.0 --namespace argocd --values ./values.yaml  你可以把他 port forward 出來看一下\nkubectl port-forward svc/argo-cd-argocd-server 8080:443 -n argocd  帳號是 admin，而密碼會自動產生，預設是 Argo-CD server 的 Pod Name\n# 醬子拿出來看 kubectl get pods -l app.kubernetes.io/name=argocd-server -o name | cut -d'/' -f 2  另外，也可以安裝 argo cli 來修改密碼\nbrew install argocd argocd login localhost:8080 argocd account update-password  開起來會看到這樣的畫面 (PS: 那兩個方框框還不會有，等一下才要裝) 按到左邊齒輪的 Settings 然後 Repositories，如果說你的 Gitlab Repo 還沒設定的話，這裡不會是綠色勾勾 Success 再來設定 ArgoCD 先來搞定 Gitlab Repo 剛剛上面填了一個 repository 的地址，現在要讓他成真 (? 總之就開一個 self_group/dev-argo Repo 在 gitlab.10oz.tw，請自己依照環境調整齁 開好了之後就點進去吧~~\n首先你需要長一個 ssh rsa key 出來\nssh-keygen -f ./argo-deploy-key  然後把你的 Public Key (argo-deploy-key.pub) 設在這裡～ 這時候 Argo 有能力去看你的 Gitlab Repo 了，他會告訴你說你的 Repo 裡面是空ㄉ喔喔喔喔\n讓我們來塞一點東西進去ㄅ，一個 application 用來設定 Argo 的監看目標，而這次監看的目標是 traefik/ingress-route 這個資料夾底下的一般 kubernetes 設定檔案\n. ├── README.md ├── applications │ ├── traefik-ingress-route.yaml └── traefik └── ingress-route └── argo-route.yaml  applications/traefik-ingress-route.yaml\nkind: Application apiVersion: argoproj.io/v1alpha1 metadata: name: golang-traefik-ingress-route namespace: argocd spec: project: default destination: name: in-cluster namespace: traefik source: path: traefik/ingress-route repoURL: 'git@gitlab.10oz.tw:self_group/dev-argo.git' targetRevision: HEAD syncPolicy: automated: prune: true  traefik/ingress-route/argo-route.yaml\nkind: IngressRoute apiVersion: traefik.containo.us/v1alpha1 metadata: name: argocd-server-route namespace: argocd spec: routes: - kind: Rule match: Host(`foo.10oz.tw`) \u0026amp;\u0026amp; PathPrefix(`/argo`) services: - name: argo-cd-argocd-server port: 80  Commit 推出去，就醬子就能動了喔 👍👍\nRef https://argoproj.github.io/argo-cd/#quick-start https://www.qikqiak.com/post/gitlab-ci-argo-cd-gitops/\n","id":2,"section":"posts","summary":"你問阿狗是什麼 GitOps + Kubernetes 的產物，相當不錯的運維工具 先來裝 Argo CD 我們要用 helm 安裝裝起來喔 helm repo add argo-cd https://argoproj.github.io/argo-helm helm repo update 來準備個 values.yaml installCRDs: false global: image: tag: v1.8.6 dex: enabled: false server: extraArgs: - --insecure # 如果說你","tags":["argo","cd","gitlab"],"title":"究竟阿狗能做什麼呢","uri":"https://blog.10oz.tw/20210409-what-can-argocd-do/","year":"2021"},{"content":"發現 k8s 機器的硬碟空間滿了 滿了耶！！怎麼會這樣 趁還有空間趕快 ssh 進去看一眼\ndev@k8s07:~$ df -h Filesystem Size Used Avail Use% Mounted on udev 5.9G 0 5.9G 0% /dev tmpfs 1.2G 4.5M 1.2G 1% /run /dev/mapper/ubuntu--vg-ubuntu--lv 98G 70G 23G 76% / tmpfs 5.9G 0 5.9G 0% /dev/shm tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 5.9G 0 5.9G 0% /sys/fs/cgroup /dev/sda2 976M 213M 696M 24% /boot tmpfs 1.2G 0 1.2G 0% /run/user/1000  閉眼先清空一波 Docker image, volumn\u0026hellip;\ndocker system prune -a  檢查一下還有啥米東西佔用了我們的空間\nsudo du -ahx / | sort -rh | head -n 20  find /var/lib/docker/ -name \u0026quot;*.log\u0026quot; -exec ls -sh {} \\; | sort -h -r | head -20  一看發現原來我有一個 30G 一個 18G 的 docker logs，有夠大啦😂 看一下 log 內容就發現了原因是最近新增的爬蟲的關係 QQ (還有 fluent-bit 也不小)\n解決他 沒事沒事，之前可能大意了沒有想到這種 Case 簡單加個規則就好了\ncat \u0026gt; /etc/docker/daemon.json \u0026lt;\u0026lt;EOF { \u0026quot;exec-opts\u0026quot;: [\u0026quot;native.cgroupdriver=cgroupfs\u0026quot;], \u0026quot;log-driver\u0026quot;: \u0026quot;json-file\u0026quot;, \u0026quot;log-opts\u0026quot;: { \u0026quot;max-size\u0026quot;: \u0026quot;1g\u0026quot;, \u0026quot;max-file\u0026quot;: \u0026quot;3\u0026quot; }, \u0026quot;storage-driver\u0026quot;: \u0026quot;overlay2\u0026quot; } EOF  The max-size is a limit on the docker log file, so it includes the json or local log formatting overhead. And the max-file is the number of logfiles docker will maintain. After the size limit is reached on one file, the logs are rotated, and the oldest logs are deleted when you exceed max-file.\n Note: Restart Docker for the changes to take effect for newly created containers. Existing containers do not use the new logging configuration.\n # Restart docker. systemctl restart docker # 手動刪除舊的大檔案 cat /dev/null \u0026gt; 大檔案.log  一個小坑 另外要注意，我第一次寫的時候 daemon.json docker cgroup driver 設定成 systemd 就炸掉了XDD\n$ journalctl -xeu kubelet # ....something failed to run Kubelet: misconfiguration: kubelet cgroup driver: \u0026quot;cgroupfs\u0026quot; is different from docker cgroup driver: \u0026quot;systemd\u0026quot; # ...something  Ref https://www.linode.com/community/questions/16922/my-disk-is-filling-up-how-can-i-find-the-culprit https://docs.docker.com/config/containers/logging/configure/#configure-the-default-logging-driver https://stackoverflow.com/questions/31829587/docker-container-logs-taking-all-my-disk-space\n","id":3,"section":"posts","summary":"發現 k8s 機器的硬碟空間滿了 滿了耶！！怎麼會這樣 趁還有空間趕快 ssh 進去看一眼 dev@k8s07:~$ df -h Filesystem Size Used Avail Use% Mounted on udev 5.9G 0 5.9G 0% /dev tmpfs 1.2G 4.5M 1.2G 1% /run /dev/mapper/ubuntu--vg-ubuntu--lv 98G 70G 23G 76% / tmpfs 5.9G 0 5.9G 0% /dev/shm tmpfs","tags":["docker","linux","log"],"title":"啥? k8s node 硬碟空間滿了","uri":"https://blog.10oz.tw/20210402-what-k8s-node-disk-full/","year":"2021"},{"content":"流水帳開始 😂 Terraform 先裝點東西吧 來安裝 terraform\nbrew tap hashicorp/tap brew install hashicorp/tap/terraform  首先登入你的 aws iam 建立一組 Access key, Secret key\n直接產一個 main.tf 檔案~ 下面有指令直接來跑跑看，你應該要多一個 ec2 機器👍\nprovider \u0026quot;aws\u0026quot; { # access_key = \u0026quot;$AWS_ACCESS_KEY_ID\u0026quot; # secret_key = \u0026quot;$AWS_SECRET_ACCESS_KEY\u0026quot; region = \u0026quot;ap-northeast-1\u0026quot; } data \u0026quot;aws_ami\u0026quot; \u0026quot;ubuntu\u0026quot; { most_recent = true filter { name = \u0026quot;name\u0026quot; values = [\u0026quot;ubuntu/images/hvm-ssd/ubuntu-bionic-18.04-amd64-server-*\u0026quot;] } filter { name = \u0026quot;root-device-type\u0026quot; values = [\u0026quot;ebs\u0026quot;] } filter { name = \u0026quot;virtualization-type\u0026quot; values = [\u0026quot;hvm\u0026quot;] } owners = [\u0026quot;099720109477\u0026quot;] # Canonical } # resource \u0026lt;resource_type\u0026gt; \u0026lt;resource_name\u0026gt; resource \u0026quot;aws_instance\u0026quot; \u0026quot;example\u0026quot; { ami = data.aws_ami.ubuntu.id instance_type = \u0026quot;t2.micro\u0026quot; }  上面這一段開一個基本 ec2 instance 的範例，其實官方有教 點我\n第一次進來要先初始化一下！\nterraform init  terraform fmt # 格式化文件 terraform plan # 檢查與線上版本的差異 terraform apply # 準備部署 注意喔，再來個 yes 你就發射出去了 # terraform destroy  kOps 出現了 跟隨官方腳步走，kOps 帶你部署 terraform \u0026raquo; 點我 networking 那邊可以選你需要的 CNI，不填寫也可以動啦，不過你會得到預設的 Kubenet\nkops create cluster \\ --networking calico \\ --name=ptcg.10oz.tw \\ --state=s3://ptcg-bucket-tf \\ --dns-zone=ptcg.10oz.tw \\ --zones=ap-northeast-1a \\ --out=. \\ --target=terraform  會看到以下的 log\nI0331 02:43:11.734871 11785 new_cluster.go:231] Inferred \u0026quot;aws\u0026quot; cloud provider from zone \u0026quot;ap-northeast-1a\u0026quot; I0331 02:43:12.025276 11785 subnets.go:180] Assigned CIDR 172.20.32.0/19 to subnet ap-northeast-1a I0331 02:43:13.000070 11785 create_cluster.go:713] Using SSH public key: /Users/xiaorenhao/.ssh/id_rsa.pub I0331 02:43:17.504798 11785 executor.go:111] Tasks: 0 done / 79 total; 45 can run I0331 02:43:17.521376 11785 dnszone.go:242] Check for existing route53 zone to re-use with name \u0026quot;ptcg.10oz.tw\u0026quot; W0331 02:43:17.904862 11785 vfs_castore.go:604] CA private key was not found I0331 02:43:18.010251 11785 keypair.go:195] Issuing new certificate: \u0026quot;etcd-clients-ca\u0026quot; I0331 02:43:18.017672 11785 keypair.go:195] Issuing new certificate: \u0026quot;etcd-peers-ca-events\u0026quot; I0331 02:43:18.022377 11785 keypair.go:195] Issuing new certificate: \u0026quot;etcd-manager-ca-events\u0026quot; I0331 02:43:18.022427 11785 keypair.go:195] Issuing new certificate: \u0026quot;apiserver-aggregator-ca\u0026quot; W0331 02:43:18.022450 11785 vfs_castore.go:604] CA private key was not found I0331 02:43:18.022474 11785 keypair.go:195] Issuing new certificate: \u0026quot;ca\u0026quot; I0331 02:43:18.029875 11785 keypair.go:195] Issuing new certificate: \u0026quot;master\u0026quot; I0331 02:43:18.034989 11785 keypair.go:195] Issuing new certificate: \u0026quot;etcd-manager-ca-main\u0026quot; I0331 02:43:18.131053 11785 keypair.go:195] Issuing new certificate: \u0026quot;etcd-peers-ca-main\u0026quot; I0331 02:43:18.247347 11785 dnszone.go:249] Existing zone \u0026quot;ptcg.10oz.tw.\u0026quot; found; will configure TF to reuse I0331 02:43:19.689156 11785 executor.go:111] Tasks: 45 done / 79 total; 16 can run I0331 02:43:19.694681 11785 executor.go:111] Tasks: 61 done / 79 total; 16 can run I0331 02:43:20.133663 11785 executor.go:111] Tasks: 77 done / 79 total; 2 can run I0331 02:43:20.134776 11785 executor.go:111] Tasks: 79 done / 79 total; 0 can run I0331 02:43:20.156638 11785 target.go:221] Terraform output is in . I0331 02:43:20.433778 11785 update_cluster.go:313] Exporting kubecfg for cluster kops has set your kubectl context to ptcg.10oz.tw Terraform output has been placed into . Run these commands to apply the configuration: cd . terraform plan terraform apply Suggestions: * validate cluster: kops validate cluster --wait 10m * list nodes: kubectl get nodes --show-labels * ssh to the master: ssh -i ~/.ssh/id_rsa ubuntu@api.ptcg.10oz.tw * the ubuntu user is specific to Ubuntu. If not using Ubuntu please use the appropriate user based on your OS. * read about installing addons at: https://kops.sigs.k8s.io/operations/addons.  會看見 kOps 幫你建立好了可以開啟 Kubernetes 服務的 terraform 檔案，直接給他跑下去\nterraform plan terraform apply  跑完後用這個指令來檢查你的 k8s cluster 是否有健康跑起來了\nkops validate cluster --wait 10m  開出來的 admin token 一天就會過期，建議是自己建立一個適合自己用的 Service Account， 不過你需要 admin token 的時候可以這麼做\nkops export kubecfg --admin  附錄：我想你會需要 Ingress Route\nkubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v0.44.0/deploy/static/provider/cloud/deploy.yaml  打完收工 kops delete cluster \\ --name=ptcg.10oz.tw \\ --state=s3://ptcg-bucket-tf \\ --yes  terraform destroy  然後建議要多人工檢查一下，因為我下完指令後很開心的洗洗睡了，隔天才注意到 Mount 的 PV 沒有幫我刪掉QQ 下次請記得到 EC2 Volume 看看喔！！\nRef https://shazi7804.github.io/terraform-manage-guide/command/plan.html https://medium.com/@chihsuan/terraform-%E8%87%AA%E5%8B%95%E5%8C%96%E7%9A%84%E5%9F%BA%E7%A4%8E%E6%9E%B6%E6%A7%8B%E4%BB%8B%E7%B4%B9-f827e8975e98 https://godleon.github.io/blog/DevOps/terraform-getting-started/\n","id":4,"section":"posts","summary":"流水帳開始 😂 Terraform 先裝點東西吧 來安裝 terraform brew tap hashicorp/tap brew install hashicorp/tap/terraform 首先登入你的 aws iam 建立一組 Access key, Secret key 直接產一個 main.tf 檔案~ 下面有指令直接來跑跑看，你應該要多一個 ec2 機器","tags":["terraform","kops"],"title":"想用 Terraform 與 kOps 也得寫個筆記","uri":"https://blog.10oz.tw/20210331-terraform-and-kops-need-a-note/","year":"2021"},{"content":" 這是發生在測試鏈 Rinkeby 與 EIP-1559 的故事 也是沒有好好更新節點版本又不認真追時事的故事\n 事件發生 大約在晚上 11 點，在家裡測試 SIT 環境的 feature 時，剛好需要幫我的以太錢包充值 發現！ 不妙！ 充不進去耶，怎麼沒反應咧？\n找 log 但一切正常，這時發現卡在 8,290,928 想說這個位置是不是發生了什麼奇怪的交易，來查查看好了～ google 後發現， EIP 1559 實裝在 Rinkeby 惹！ 雖然之前沒有認真關注這個提案，但還是知道他是一個吵很大的硬分叉 馬上 ssh 連到我們的 full node 去看看，最高節點就是在 8,290,928 的位置\n好啦，找到原因了～～ 我們來跟一下硬分叉吧\n更新一下 首先下載最新的包~~\nsudo add-apt-repository -y ppa:ethereum/ethereum -y apt-cache policy ethereum # 確認版本 sudo apt-get upgrade ethereal geth version # 確認版本  然後重啟就好囉\n# 再重新開回服務 geth --rinkeby --http --http.addr 0.0.0.0 --ws --ws.addr 0.0.0.0 --ws.origins * --rpcvhosts=*  知道問題後就也不難了，但是開發這個真的要跟時事呀😂\n不然會跟我一樣，都分叉一天了才發現自己的服務沒有更新 QQ\n","id":5,"section":"posts","summary":"這是發生在測試鏈 Rinkeby 與 EIP-1559 的故事 也是沒有好好更新節點版本又不認真追時事的故事 事件發生 大約在晚上 11 點，在家裡測試 SIT 環境的 feature 時，剛好需要幫我的以太錢","tags":["blockchain","ethereum","geth"],"title":"小紀錄更新 Rinkeby Ethereum 節點","uri":"https://blog.10oz.tw/20210326-little-bit-update-rinkeby-ethereum/","year":"2021"},{"content":"問題描述 helm release 明明就存在，但是他就是跟你說沒有部署的版本\nError: UPGRADE FAILED: \u0026quot;code-server\u0026quot; has no deployed releases  處理一下 原來是狀態不對，可能上一次部署的時候失敗了，只要你加上 --force 再給他跑下去就好\n或者說去找到 secrets sh.helm.release.v1.{server_name}.v{version} 修改一下裡面的 labels status，改成 deployed\nmetadata: name: sh.helm.release.v1.code-server.v31 namespace: foo uid: b94b5861-8f98-4e8c-bb81-e715975d8c22 resourceVersion: '46153334' creationTimestamp: '2021-03-04T06:12:08Z' labels: modifiedAt: '1614838331' name: code-server owner: helm status: failed # 改這裏成 deployed version: '31'  再重新 Retry 一下 helm upgrade 就可以囉\n","id":6,"section":"posts","summary":"問題描述 helm release 明明就存在，但是他就是跟你說沒有部署的版本 Error: UPGRADE FAILED: \u0026quot;code-server\u0026quot; has no deployed releases 處理一下 原來是狀態不對，可能上一次部署的時候失敗了，只要你加上 --force 再給他","tags":["kubernetes","helm"],"title":"helm3 說 has no deployed releases","uri":"https://blog.10oz.tw/20210326-helm3-has-no-deployed-releases/","year":"2021"},{"content":" GitLab Community Edition 12.7.0 go version go1.15 darwin/amd64\n 問題描述 事實上這次包含兩個問題，一個是 Privite Gitlab 的認證另一個是 Gitlab Subgroup 的支援\nPrivite Gitlab 存取私有的 Gitlab 可以修改你的 go env\nexport GOPRIVATE=gitlab.company.com.tw  Subgroup 你的 go.mod\nmodule example.com/test require gitlab.com/org/subgroup/repo/pkg/foo v0.0.0 replace gitlab.com/org/subgroup/repo/pkg/foo =\u0026gt; gitlab.com/org/subgroup/repo.git/pkg/foo v1.0.0  Ref https://gitlab.com/gitlab-org/gitlab-foss/-/issues/30785\n","id":7,"section":"posts","summary":"GitLab Community Edition 12.7.0 go version go1.15 darwin/amd64 問題描述 事實上這次包含兩個問題，一個是 Privite Gitlab 的認證另一個是 Gitlab Subgroup 的支援 Privite Gitlab 存取私有的 Gitlab 可以修改你的 go env export GOPRIVATE=gitlab.company.com.tw Subgroup 你的 go.mod module example.com/test require gitlab.com/org/subgroup/repo/pkg/foo v0.0.0 replace gitlab.com/org/subgroup/repo/pkg/foo","tags":["golnag","gitlab","subgroup"],"title":"go get 與私有 Gitlab","uri":"https://blog.10oz.tw/20210316-go-get-privite-gitlab-repo/","year":"2021"},{"content":"問題描述 這幾天工作遇到 chromedp 爬蟲執行完後沒有被關閉！ 導致 memory 不斷堆積\n因為監測 metrics 的最小單位是 container，一開始調查以為是程式記憶體過高所以嘗試用 pprof 錄了一段後發現沒有直接的上升，於是直接進入容器裡面觀察 process 佔用的資源\n哇嗚，發現好多 chrome 的屍體 好了，開始研究為什麼 chromedp 沒幫我們把它關掉。 此時發現一張 Issue 有這個問題和其他人的研究成果\n解決方法 其實解決方法 chromedp 已經給你了\nFROM chromedp/headless-shell:latest ... # Install dumb-init or tini RUN apt install dumb-init # or RUN apt install tini ... ENTRYPOINT [\u0026quot;dumb-init\u0026quot;, \u0026quot;--\u0026quot;] # or ENTRYPOINT [\u0026quot;tini\u0026quot;, \u0026quot;--\u0026quot;] CMD [\u0026quot;/path/to/your/program\u0026quot;]  就是第 7 行的那個，在 docker image 中不要直接去跑你的程式而是用 dumb-init 去包起來跑！ 就可以避免殭屍進程了\n原因是這樣的，一般來說在執行 OS 的時候 Pid 為 1 的服務會是系統服務(ex: systemd, launchd)，然而在 Container 裡面 Pid=1 是我們自己的程式！\n $ man launchd launchd(8) BSD System Manager\u0026rsquo;s Manual launchd(8)\nNAME launchd \u0026ndash; System wide and per-user daemon/agent manager\n 當一個 Process 被關閉時，他的 SubProcess 會被託管給 Pid=1 的 Process，但是我們寫的程式並沒有託管的功能所以那些 SubProcess 就被 hang 在那邊成為殭屍。\n更多深入了解可以看 dumb-init github 和 dumb-init：一个 Docker 容器初始化系统\nRef https://github.com/chromedp/chromedp/issues/752 https://github.com/chromedp/docker-headless-shell#using-as-a-base-image https://github.com/Yelp/dumb-init 詳細說明 https://www.infoq.cn/article/2016/01/dumb-init-docker\n","id":8,"section":"posts","summary":"問題描述 這幾天工作遇到 chromedp 爬蟲執行完後沒有被關閉！ 導致 memory 不斷堆積 因為監測 metrics 的最小單位是 container，一開始調查以為是程式記憶體過高所以嘗","tags":["chromedp","chromium","golang","linux"],"title":"Chromedp 殭屍進程","uri":"https://blog.10oz.tw/20210306-chromedp-zombi-process/","year":"2021"},{"content":"GFW (great fire wall) 中國大陸在 2008 年啟動的計畫，監管所有的網路流量並且阻擋許多境外的網站和不受允許的 IP，例如說 youtube, google search, facebook 都是被禁止的。也因此有了翻牆找自由的需求，幫 QQ\nGFW 擋掉的方法有域名污染、關鍵字阻斷、特徵攔截\u0026hellip;等等，只要他看見你的封包含有他不喜歡的關鍵字，或是黑名單的 IP 就直接斷掉你的網路封包。\n因此想要繞過 GFW 的審核，就需要用上封包加密，他看不懂的東西他不會隨便的就把你給封鎖掉，也就有機會可以碰觸到外面的世界。 不過這樣會面臨到另一個問題，加密的內容 GFW 看不懂，google 也一樣看不懂，因此需要有一台跳板機來解密，然後跳板機幫你做到你真正想要做的事情，再將結果加密傳回去給你。\n常用技術與工具們 VPS (Virtual Private Server) 也就是跳板機啦，常用的供應商有 Linode, Vultr，都是老牌穩定價格合理的廠商。\n他們會租借一台虛擬的主機和 IP 給你，就好像有一台實際的電腦，你可以連線進去在上面做任何的事情~~ 當然也包含架設 VPN 跳板喔\nsocks5 跑在第五層(Session Layer)的代理服務，很常被用來作為 VPN 服務的代理，不過這個協定不包含加密，因此一般會再搭配其他服務一起使用。 另外他無法做到全局代理，例如更低層級的 TCP, ICMP 這些協定，你 ping 回來還會是自己的 IP\n可以使用類似 tun2sock 這類工具，轉換所有的流量至 socks5，以達到全局代理的效果，當然別忘記還沒加密嘿\nShadowSocks (SS, SSR) 最有知名度的翻牆工具，內容就是簡單的對封包做對稱加密，支援多種加密法，也有各種語言實作套件，不過也因為他簡單所以有很多人都表示這種翻牆的特徵已經能夠被 GFW 識別出來了，然而目前的翻牆最大宗還是使用 ShadowSocks 再加上 socks5 代理\n然後作者在 github 上突然的消失好幾個月惹，大家都說他被中國政府抓去喝茶惹\nSSR(ShadowSocksR) 是 ShadowSocks 的 fork 修改版\nV2Ray 來自 Project V，V2Ray 專案就是個超級綜合包，支援許多種不同的協議(當然也包含 ShasowSocks)，可以自定義出口協定、入口協定、白名單\u0026hellip;，抽象程度很高可以彈性的做變化，也因此複雜度相當高\n也有發行自己的協議 - VMess，他是基於 TLS 的加密演算法，用於保護內容，混淆特徵。\n平台上推薦的用法是 VMess + WSS，也就是用 vemss 協議加密再透過 TLS 加密過的 websocket 傳輸，加完密基本上從外觀上看就是一個跟所有人都一樣的正常 websocket 連線，而且被 GFW 抓走的案例也相對少很多，因此被認為是一個主流的翻牆方式～～\nTrojan 不太認識這個QQ，是個後來出現的明日之星(?\n他和 V2Ray 相同也是跑在 WSS 上做加密、混淆，不過他不像 V2Ray 有這麼多的選擇，也就更輕量更簡單。\n專線(IPLC, IEPL) 中國內部的網路有幾種線路，常見的 163, CN2\u0026hellip; 還有其他幾種骨感網路的流量，不是很了解但知道他們都是要過 GFW 的。\nIPLC 就厲害啦，他不過 GFW 所以不用翻！不過這線路貴得很，基本不在選項內 XDD\nTODO嗎 像是傳統的 VPN 協議就會有明顯的特徵， PPTP L2TP openVPN SSTP\u0026hellip;\nRef https://www.v2ray.com/developer/intro/guide.html https://www.youtube.com/watch?v=XKZM_AjCUr0\u0026amp;list=PLqybz7NWybwUgR-S6m78tfd-lV4sBvGFG https://github.com/trojan-gfw/trojan https://wivwiv.com/post/ssr-v2ray-trojan/ https://blog.wongcw.com/2019/07/03/iepl%E3%80%81iplc%E8%A9%B3%E7%B4%B0%E4%BB%8B%E7%B4%B9%E5%8F%8A%E5%8D%80%E5%88%A5/\n","id":9,"section":"posts","summary":"GFW (great fire wall) 中國大陸在 2008 年啟動的計畫，監管所有的網路流量並且阻擋許多境外的網站和不受允許的 IP，例如說 youtube, google search, facebook 都是被禁止的。也因此有了翻牆找自由","tags":["gfw","vpn"],"title":"VPN \u0026 GFW - 科學上網","uri":"https://blog.10oz.tw/20210124-vpn-and-gfw/","year":"2021"},{"content":"關於 protobuf null value golang 預設建出來的是沒有指標的，但是有時候就是需要指標來判斷啊！\noption protobuf v3 從 1.12 開始支援實驗性功能 option，讓用戶可以像是 v2 時一樣使用 option 去產生一個 nullable 的欄位\nsyntax = \u0026quot;proto3\u0026quot;; message Foo { int32 bar = 1; optional int32 baz = 2; }  https://stackoverflow.com/a/62566052/6695274\nwrappers 不過， gogo-proto 並不支援阿QQ，\n但也不能就這麼捨棄 gogo-proto，因此我們需要選擇另一個方案\nimport \u0026quot;google/protobuf/wrappers.proto\u0026quot;; message Foo { int32 bar = 1; google.protobuf.Int32Value baz = 2; }  https://stackoverflow.com/a/50099927/6695274\n記得在 --go-output= 內加上 Mgoogle/protobuf/wrappers.proto=github.com/gogo/protobuf/types\n但是但是，無法支援 enum 我難過\ncustom wrappers 只好自己動手做 (?\nenum Status { STATUS_OK = 0; STATUS_FAIL = 1; } message NullInt32 { bool valid = 1; int32 value = 2; } message NullStatus { bool valid = 1; Status value = 2; } message Foo { int32 bar = 1; NullInt32 baz = 2; NullStatus status = 3; }  gen 成 golang 的 code 之後就這樣用，基本上跟 wrappers 的用法是一樣的\ntype NullStatus struct { Valid bool `protobuf:\u0026quot;varint,1,opt,name=valid,proto3\u0026quot; json:\u0026quot;valid,omitempty\u0026quot;` Value Status `protobuf:\u0026quot;varint,2,opt,name=value,proto3,enum=blackblock.Status\u0026quot; json:\u0026quot;value,omitempty\u0026quot;` XXX_NoUnkeyedLiteral struct{} `json:\u0026quot;-\u0026quot;` XXX_unrecognized []byte `json:\u0026quot;-\u0026quot;` XXX_sizecache int32 `json:\u0026quot;-\u0026quot;` } func (m *NullStatus) GetValid() bool { if m != nil { return m.Valid } return false } func (m *NullStatus) GetValue() Status { if m != nil { return m.Value } return Status_STATUS_OK } type Foo struct { Bar int32 `protobuf:\u0026quot;varint,1,opt,name=bar,proto3\u0026quot; json:\u0026quot;bar,omitempty\u0026quot;` Baz *NullInt32 `protobuf:\u0026quot;bytes,2,opt,name=baz,proto3\u0026quot; json:\u0026quot;baz,omitempty\u0026quot;` Status *NullStatus `protobuf:\u0026quot;bytes,3,opt,name=status,proto3\u0026quot; json:\u0026quot;status,omitempty\u0026quot;` XXX_NoUnkeyedLiteral struct{} `json:\u0026quot;-\u0026quot;` XXX_unrecognized []byte `json:\u0026quot;-\u0026quot;` XXX_sizecache int32 `json:\u0026quot;-\u0026quot;` }  好啦，希望不要用到啦😅\n","id":10,"section":"posts","summary":"關於 protobuf null value golang 預設建出來的是沒有指標的，但是有時候就是需要指標來判斷啊！ option protobuf v3 從 1.12 開始支援實驗性功能 option，讓用戶可以像是 v2 時一樣使用 option","tags":null,"title":"gRPC - protobuf v3 產生 nullable 欄位","uri":"https://blog.10oz.tw/20201123-nullable-column-in-protobuf-v3/","year":"2020"},{"content":"開始安裝 下載後會得到一個資料夾 istio-1.7.4 把他加入你的執行檔中吧\ncurl -L https://istio.io/downloadIstio | sh - export PATH=$PWD/istio-1.7.4/bin:$PATH istioctl version # 成功就是有囉  預設的 Profile 們有六個，我就先用 default 吧\n    default demo minimal remote empty preview      Core components          istio-egressgateway  X        istio-ingressgateway X X    X    istiod X X X   X     istioctl profile list istioctl install --set profile=default  裝好之後來實驗一下喔，開一個新的 namespce 並安裝官方範例 book info，裡面包含 4 個微服務\nkubectl create namespcae istio-bookinfo # kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml kubectl apply -n istio-bookinfo -f https://raw.githubusercontent.com/istio/istio/release-1.7/samples/bookinfo/platform/kube/bookinfo.yaml  目前的 pod 裡面都只有 1 個 Container，我們要注入 istio 的 envoy proxy 讓每個 Pod 裡面多一個 sidecar\n\u0026gt; ~/istio » kubectl get po -n istio-bookinfo NAME READY STATUS RESTARTS AGE details-v1-79c697d759-9kvrq 1/1 Running 0 3m41s productpage-v1-65576bb7bf-w9gf6 1/1 Running 0 3m38s ratings-v1-7d99676f7f-tq9kw 1/1 Running 0 3m40s reviews-v1-987d495c-j655s 1/1 Running 0 3m40s reviews-v2-6c5bf657cf-l595s 1/1 Running 0 3m39s reviews-v3-5f7b9f4f77-4qdtb 1/1 Running 0 3m39s  kubectl label namespace istio-bookinfo istio-injection=enabled kubectl get namespace -L istio-injection # 重新部署，就把 Pod 都刪掉吧 kubectl delete (kubectl get all | grep pod | awk '{print $1}')  如果要關掉的話\nkubectl label namespace default istio-injection-  再來看看，是不是每個 Pod 裡面都多一個 Container 啦~\n\u0026gt; ~/istio » kubectl get pod NAME READY STATUS RESTARTS AGE details-v1-79c697d759-lqt6k 2/2 Running 0 3m15s productpage-v1-65576bb7bf-zwgqd 2/2 Running 0 3m15s ratings-v1-7d99676f7f-fqvvd 2/2 Running 0 3m15s reviews-v1-987d495c-kbc4z 2/2 Running 0 3m14s reviews-v2-6c5bf657cf-749bn 2/2 Running 0 3m14s reviews-v3-5f7b9f4f77-f7wvk 2/2 Running 0 3m14s  我們的服務目前長這樣 kubectl port-forward svc/productpage 9080:9080 -n istio-bookinfo  利用 Kaili 視覺化 traffic # 詳細內容在 https://github.com/istio/istio/tree/1.7.0/samples/addons kubectl apply -f samples/addons  檢查 namespace istio-system 內，多了 grafana, kiali, prometheus, tracing, zipkin 這幾個服務\n來看看 kaili 喔～\nport-forward svc/kiali 20001:20001 -n istio-system  kaili 可以用流量直接幫我們畫出 service 之間的關係圖 Reference https://istio.io/latest/docs/setup/getting-started/ https://istio.io/latest/docs/setup/additional-setup/config-profiles/ https://istio.io/latest/docs/examples/bookinfo/\n","id":11,"section":"posts","summary":"開始安裝 下載後會得到一個資料夾 istio-1.7.4 把他加入你的執行檔中吧 curl -L https://istio.io/downloadIstio | sh - export PATH=$PWD/istio-1.7.4/bin:$PATH istioctl version # 成功就是有囉 預設的 Profile 們有六個，我就先用 default 吧 default demo minimal remote empty preview Core components istio-egressgateway X istio-ingressgateway","tags":["kubernetes","istio","service-mesh"],"title":"新米 Istio - 安裝篇","uri":"https://blog.10oz.tw/20201115-a-istio-beginner/","year":"2020"},{"content":"介紹一下 在遇見 GraphQL 的時候最常被比較的就是 Restful API，畢竟 Rustful API 是目前的主流設計，此時我們就必須了解到什麼情況下使用 GraphQL 能帶來效益\n Over Fetch Restful API 的回傳會是一整個 resource， /user/1 會回傳 id=1 的 User 的全部資料，然而在很多情況下我們不需要這麼多的資料，可能 我們僅僅只需要 user 的名字而已 在 GraphQL 你可以指定你所需要的欄位，大大的減少了傳輸無用資料的消耗 Under Fetch 也就是 n+1 問題，情景是 user 有很多的 friends，每個朋友都是一名 User，在 Restful 的設計中，每個 User resource 都是一支 API，想想就頭痛 QQ。因此會在後端客製化 API 做 eager loading，一次回傳這些資料 但到了 GraphQL 這完全不是問題，你可以向下定義你所需要的資料，並嵌入 User 中 query { User(id: 1) { Name AvatarURL friends { ID Name } } }    在設計上，GraphQL 關注 明確的解釋查詢語言與型態系統 而不去描述伺服器端實作，前後端之間以 Schema 定義溝通介面，雙方有共通的資料型態以及明確定義的詞彙來討論\n讓一切清楚且簡單～\n怎麼用r 工具會用一點 - GraphQL Playground 認識一些 GraphQL Schema GraphQL 定義自己的語法格式，他是個 SDL (Schema Define Language)\n首先來定義一個 type 也就是基本的物件，基本型別有 Int Float String Boolean ID，也可以用 ! 來定義該欄位是否是 Nullable 的\ntype Student { id: Int! name: String! \u0026quot;可以寫註解說每個學生都有 sid\u0026quot; studentID: String! \u0026quot;\u0026quot;\u0026quot; 多行註解說： 每個學生都可以填一個電話 \u0026quot;\u0026quot;\u0026quot; phone: Phone \u0026quot;\u0026quot;\u0026quot; 每個人都可以發很多文 \u0026quot;\u0026quot;\u0026quot; articles: [Article!] } type Phone { phoneNumber: String! } type Article { title: String! content: String! }  基本型別不夠用嗎，我們來自定義一下，Date 然後這個型別的實作要伺服器端自己來喔\nscalar Date # 用法這樣 type Article2 { title: String! content: String! date: Date! }  也可以定義枚舉類別(enumeration)\nenum GradingStatus { INPROGRESS GRADUATED } type Student2 { gradingStatus: GradingStatus! }  當你的物件可能是不同的結構時，你可以找 union\n\u0026quot;\u0026quot;\u0026quot; union 定義 User 可能是 Student 也可能是 Teacher \u0026quot;\u0026quot;\u0026quot; union User = Student | Teacher  或是 interface 也能滿足你的需求\ninterface User { id: ID! name: String! phone: Phone } type Student implements User { id: ID! name: String! phone: Phone # 你還可以定義更多更多... } type Teacher implements User { id: ID! name: String! phone: Phone # 你還可以定義更多更多... }  query mutation 驚嘆號 (enum with default)\n語法知道一下 (query, mutation, subscription) 有三種基本語法 query, mutation, subscription\nquery 可以簡單想像他是 RestfulAPI 中的 GET，用來拿各種資料\nfragment 可以抽出常用的結構來簡化語法\nquery { me { ...UserBrief } # 可以一次定義多個 query user(name: \u0026quot;foo\u0026quot;) { id ...UserBrief } } # fragment 可以幫助重用參數 fragment UserBrief on User { name email }  union 有時候回傳的不一定是同一種物件，這時候可以這麼做\n# 一個 people 可能是 Teacher 或是 Student，不同的 type 會回傳不同的內容 query people { ...on Teacher { teacherID name } ...on Student { studentID name grade } } # 等價的，你也可以寫成這樣 query people { ...pTeacher ...pStudent } fragment pTeacher on Teacher { teacherID name } fragment pStudent on Student { studentID name grade }  mutation 可以簡單想像他是 RestfulAPI 中的 POST，用來變更資料\nmutation { newUser(name: \u0026quot;foo\u0026quot; email: \u0026quot;bar@mail.tw\u0026quot;) { id # 回傳的 id ...UserBrief } } fragment UserBrief on User { name email }  也可以用 $ 開頭寫點變數\nmutation create($name: String $email: String) { newUser(name: $name email: $email) { id # 回傳的 id ...UserBrief } } fragment UserBrief on User { name email }  subscription 建立 websocket 長連線來接收資料的變更，用法跟 query 很像，在資料變更時就收到訊息囉\nsubscription { me { name email } }  Introspection 自我查詢 GraphQL 可以利用自我查詢來取得目前的 Schema\nquery ListTypes { __schema { # 取得 gql 定義了哪些 Types types { kind # Object, InputObject, Enum, Scalar name description # 這裡也可以直接 fields 拿詳細資訊 } } } query TypeDetail { # 我們想要拿 Role 這個 Type 的詳細資料 __type(name: \u0026quot;Role\u0026quot;) { name kind fields { name type { ofType{ name } } } } }  query IntrospectionQuery { # 我要拿全部操作(query, mutation, subscription) __schema { queryType { ...OprationDetail } mutationType { ...OprationDetail } subscriptionType { ...OprationDetail } } } fragment OprationDetail on __Type { name fields { name type { ofType{ name } } } }  graphQL 自帶文件，具備一般 API Server 沒有的優勢，棒棒ㄉ\nHASURA https://cloud.hasura.io/project/88f267cd-3f1b-45fa-a1e1-a7ceed6ba10a/env-vars\nRef Think in GraphQL https://ithelp.ithome.com.tw/users/20111997/ironman/1878 https://graphql.org/learn/schema/\n","id":12,"section":"posts","summary":"介紹一下 在遇見 GraphQL 的時候最常被比較的就是 Restful API，畢竟 Rustful API 是目前的主流設計，此時我們就必須了解到什麼情況下使用 GraphQL 能帶來效益 Over Fetch Restful API 的回傳會是一","tags":["graphql","gql"],"title":"GraphQL 打招呼","uri":"https://blog.10oz.tw/20201009-hello-graphql/","year":"2020"},{"content":"好文章推推，直接抄爆 https://learnku.com/articles/24924\n設定開始 撰寫設定檔 首先 vim ~/.vimrc 改成下面這模樣\n\u0026quot;============================================================================== \u0026quot; vim 内置配置 \u0026quot;============================================================================== \u0026quot; 设置 vimrc 修改保存后立刻生效，不用在重新打开 \u0026quot; 建议配置完成后将这个关闭，否则配置多了之后会很卡 \u0026quot; autocmd BufWritePost $MYVIMRC source $MYVIMRC \u0026quot; 关闭兼容模式 set nocompatible set nu \u0026quot; 设置行号 set cursorline \u0026quot;突出显示当前行 set showmatch \u0026quot; 显示括号匹配 \u0026quot; tab 缩进 set tabstop=4 \u0026quot; 设置Tab长度为4空格 set shiftwidth=4 \u0026quot; 设置自动缩进长度为4空格 set autoindent \u0026quot; 继承前一行的缩进方式，适用于多行注释 \u0026quot; 定义快捷键的前缀，即\u0026lt;Leader\u0026gt; let mapleader=\u0026quot;,\u0026quot; \u0026quot; ==== 系统剪切板复制粘贴 ==== \u0026quot; v 模式下复制内容到系统剪切板 vmap \u0026lt;Leader\u0026gt;c \u0026quot;+yy \u0026quot; n 模式下复制一行到系统剪切板 nmap \u0026lt;Leader\u0026gt;c \u0026quot;+yy \u0026quot; n 模式下粘贴系统剪切板的内容 nmap \u0026lt;Leader\u0026gt;v \u0026quot;+p \u0026quot; 开启实时搜索 set incsearch \u0026quot; 搜索时大小写不敏感 set ignorecase syntax enable syntax on \u0026quot; 开启文件类型侦测 filetype plugin indent on \u0026quot; 启用自动补全 \u0026quot; 退出插入模式指定类型的文件自动保存 au InsertLeave *.go,*.sh,*.php write \u0026quot;============================================================================== \u0026quot; 插件配置 \u0026quot;============================================================================== \u0026quot; 插件开始的位置 call plug#begin('~/.vim/plugged') \u0026quot; Shorthand notation; fetches https://github.com/junegunn/vim-easy-align \u0026quot; 可以快速对齐的插件 Plug 'junegunn/vim-easy-align' \u0026quot; 用来提供一个导航目录的侧边栏 Plug 'scrooloose/nerdtree' \u0026quot; 可以使 nerdtree Tab 标签的名称更友好些 Plug 'jistr/vim-nerdtree-tabs' \u0026quot; 可以在导航目录中看到 git 版本信息 Plug 'Xuyuanp/nerdtree-git-plugin' \u0026quot; 支援更多 git 的功能 Plug 'tpope/vim-fugitive' Plug 'tpope/vim-rhubarb' Plug 'shumphrey/fugitive-gitlab.vim' \u0026quot; 可以在文档中显示 git 信息 Plug 'airblade/vim-gitgutter' \u0026quot; 查看当前代码文件中的变量和函数列表的插件， \u0026quot; 可以切换和跳转到代码中对应的变量和函数的位置 \u0026quot; 大纲式导航, Go 需要 https://github.com/jstemmer/gotags 支持 Plug 'majutsushi/tagbar' \u0026quot; 自动补全括号的插件，包括小括号，中括号，以及花括号 Plug 'jiangmiao/auto-pairs' \u0026quot; Vim状态栏插件，包括显示行号，列号，文件类型，文件名，以及Git状态 Plug 'vim-airline/vim-airline' \u0026quot; 代码自动完成，安装完插件还需要额外配置才可以使用 Plug 'Valloric/YouCompleteMe' \u0026quot; 下面两个插件要配合使用，可以自动生成代码块 Plug 'SirVer/ultisnips' Plug 'honza/vim-snippets' \u0026quot; 配色方案 Plug 'fatih/molokai' \u0026quot; go 主要插件 Plug 'fatih/vim-go', { 'tag': '*' } \u0026quot; go 中的代码追踪，输入 gd 就可以自动跳转 Plug 'dgryski/vim-godef' \u0026quot; markdown 插件 Plug 'iamcco/mathjax-support-for-mkdp' Plug 'iamcco/markdown-preview.vim' \u0026quot; 模糊搜尋 Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' } Plug 'junegunn/fzf.vim' \u0026quot; 多行編輯 Plug 'mg979/vim-visual-multi' \u0026quot; 搜尋 Plug 'mileszs/ack.vim' let g:ackprg = 'ag --nogroup --nocolor --column' \u0026quot; 插件结束的位置，插件全部放在此行上面 call plug#end() \u0026quot;============================================================================== \u0026quot; 主题配色 \u0026quot;============================================================================== let g:rehash256 = 1 let g:molokai_original = 1 colorscheme molokai \u0026quot; colorscheme sublimemonokai \u0026quot;============================================================================== \u0026quot; vim-go 插件 \u0026quot;============================================================================== let g:go_fmt_command = \u0026quot;goimports\u0026quot; \u0026quot; 格式化将默认的 gofmt 替换 let g:go_autodetect_gopath = 1 let g:go_list_type = \u0026quot;quickfix\u0026quot; let g:go_version_warning = 1 let g:go_highlight_types = 1 let g:go_highlight_fields = 1 let g:go_highlight_functions = 1 let g:go_highlight_function_calls = 1 let g:go_highlight_operators = 1 let g:go_highlight_extra_types = 1 let g:go_highlight_methods = 1 let g:go_highlight_generate_tags = 1 let g:go_highlight_format_strings = 1 let g:go_highlight_function_arguments = 1 let g:go_highlight_generate_tags = 1 let g:go_highlight_variable_declarations = 1 let g:godef_split=2 \u0026quot;============================================================================== \u0026quot; NERDTree 插件 \u0026quot;============================================================================== \u0026quot; 打开和关闭NERDTree快捷键 map \u0026lt;F10\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt; \u0026quot; 显示行号 let NERDTreeShowLineNumbers=1 \u0026quot; 打开文件时是否显示目录 let NERDTreeAutoCenter=1 \u0026quot; 是否显示隐藏文件 let NERDTreeShowHidden=1 \u0026quot; 设置宽度 \u0026quot; let NERDTreeWinSize=31 \u0026quot; 忽略一下文件的显示 let NERDTreeIgnore=['\\.pyc', '\\~$', '\\.swp', '.git'] \u0026quot; 打开 vim 文件及显示书签列表 let NERDTreeShowBookmarks=2 \u0026quot; 在终端启动vim时，共享NERDTree let g:nerdtree_tabs_open_on_console_startup=1 \u0026quot;============================================================================== \u0026quot; majutsushi/tagbar 插件 \u0026quot;============================================================================== \u0026quot; majutsushi/tagbar 插件打开关闭快捷键 nmap \u0026lt;F9\u0026gt; :TagbarToggle\u0026lt;CR\u0026gt; let g:tagbar_type_go = { \\ 'ctagstype' : 'go', \\ 'kinds' : [ \\ 'p:package', \\ 'i:imports:1', \\ 'c:constants', \\ 'v:variables', \\ 't:types', \\ 'n:interfaces', \\ 'w:fields', \\ 'e:embedded', \\ 'm:methods', \\ 'r:constructor', \\ 'f:functions' \\ ], \\ 'sro' : '.', \\ 'kind2scope' : { \\ 't' : 'ctype', \\ 'n' : 'ntype' \\ }, \\ 'scope2kind' : { \\ 'ctype' : 't', \\ 'ntype' : 'n' \\ }, \\ 'ctagsbin' : 'gotags', \\ 'ctagsargs' : '-sort -silent' \\ } \u0026quot;============================================================================== \u0026quot; nerdtree-git-plugin 插件 \u0026quot;============================================================================== let g:NERDTreeGitStatusIndicatorMapCustom = { \\ \u0026quot;Modified\u0026quot; : \u0026quot;✹\u0026quot;, \\ \u0026quot;Staged\u0026quot; : \u0026quot;✚\u0026quot;, \\ \u0026quot;Untracked\u0026quot; : \u0026quot;✭\u0026quot;, \\ \u0026quot;Renamed\u0026quot; : \u0026quot;➜\u0026quot;, \\ \u0026quot;Unmerged\u0026quot; : \u0026quot;═\u0026quot;, \\ \u0026quot;Deleted\u0026quot; : \u0026quot;✖\u0026quot;, \\ \u0026quot;Dirty\u0026quot; : \u0026quot;✗\u0026quot;, \\ \u0026quot;Clean\u0026quot; : \u0026quot;✔︎\u0026quot;, \\ 'Ignored' : '☒', \\ \u0026quot;Unknown\u0026quot; : \u0026quot;?\u0026quot; \\ } let g:NERDTreeGitStatusShowIgnored = 1 \u0026quot;============================================================================== \u0026quot; nerdtree-git-plugin 插件 \u0026quot;============================================================================== \u0026quot; [Buffers] Jump to the existing window if possible let g:fzf_buffers_jump = 1 nnoremap \u0026lt;leader\u0026gt;fl :Lines nnoremap \u0026lt;leader\u0026gt;fbl :BLines nnoremap \u0026lt;leader\u0026gt;ff :Files \u0026quot;============================================================================== \u0026quot; Valloric/YouCompleteMe 插件 \u0026quot;============================================================================== \u0026quot; make YCM compatible with UltiSnips (using supertab) let g:ycm_key_list_select_completion = ['\u0026lt;C-n\u0026gt;', '\u0026lt;space\u0026gt;'] let g:ycm_key_list_previous_completion = ['\u0026lt;C-p\u0026gt;', '\u0026lt;Up\u0026gt;'] let g:SuperTabDefaultCompletionType = '\u0026lt;C-n\u0026gt;' \u0026quot; better key bindings for UltiSnipsExpandTrigger let g:UltiSnipsExpandTrigger = \u0026quot;\u0026lt;tab\u0026gt;\u0026quot; let g:UltiSnipsJumpForwardTrigger = \u0026quot;\u0026lt;tab\u0026gt;\u0026quot; let g:UltiSnipsJumpBackwardTrigger = \u0026quot;\u0026lt;s-tab\u0026gt;\u0026quot; \u0026quot;============================================================================== \u0026quot; 支援更多 git \u0026quot;============================================================================== \u0026quot; GBrower gitlab let g:fugitive_gitlab_domains = ['https://gitlab.silkrode.com.tw'] let g:gitlab_api_keys = {'gitlab.silkrode.com.tw': '這個可能不能公開'} \u0026quot;============================================================================== \u0026quot; 其他插件配置 \u0026quot;============================================================================== \u0026quot; markdwon 的快捷键 map \u0026lt;silent\u0026gt; \u0026lt;F5\u0026gt; \u0026lt;Plug\u0026gt;MarkdownPreview map \u0026lt;silent\u0026gt; \u0026lt;F6\u0026gt; \u0026lt;Plug\u0026gt;StopMarkdownPreview \u0026quot; tab 标签页切换快捷键 :nn \u0026lt;Leader\u0026gt;1 1gt :nn \u0026lt;Leader\u0026gt;2 2gt :nn \u0026lt;Leader\u0026gt;3 3gt :nn \u0026lt;Leader\u0026gt;4 4gt :nn \u0026lt;Leader\u0026gt;5 5gt :nn \u0026lt;Leader\u0026gt;6 6gt :nn \u0026lt;Leader\u0026gt;7 7gt :nn \u0026lt;Leader\u0026gt;8 8gt :nn \u0026lt;Leader\u0026gt;9 8gt :nn \u0026lt;Leader\u0026gt;0 :tablast\u0026lt;CR\u0026gt;  安裝相關插件 Plug - vim 套件管理工具 我們要用 Plug 來裝插件 https://github.com/junegunn/vim-plug\nunix 版本\ncurl -fLo ~/.vim/autoload/plug.vim --create-dirs \\ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim  然後輸入 vim +PlugInstall 開始安裝 再來安裝 vim +GoInstallBinaries golang tools，雖然沒意外的話早就裝過惹呢XDD\n你完成我 - 自動補齊工具 YouCompleteMe 剛才已經用 Plug 下載下來了，不過還不能直接使用\ncd .vim/plugged/YouCompleteMe brew install cmake macvim # 可選: python mono go nodejs # 如果不指定 go 的話，他會安裝 C# Go JavaScript Rust Jaca python3 install.py --go-completer  使用者筆記 插件們 雖然剛剛裝了滿滿的 plugin 但也要會用才行rrr 😂😂\nNERDTree - 左邊的 Sidebar  C_w + [上下左右] 切換到 [上下左右] 的分割視窗 C_w + w 切換到下一個分割視窗 在 NERDTress 對檔案 t 開啟新分頁 在 NERDTress 對檔案 o 開啟新分頁，並跳過去 在 NERDTress 對資料夾 o 展開/縮合資料夾 在 NERDTress 按下 m 會進入檔案管理模式，再來按 a 可以新增檔案 切換到指定分頁 \u0026lt;Leader\u0026gt;[1-9] 或是上面有設定 [1-9]gt  vim-fugitive 提供了很多在 vim 上面整合 git 的功能  :Gdiffsplit 水平分割 git diff 畫面 (上下) :Gvdiff 垂直分割 git diff 畫面 (看左右好像比較習慣) :GBrowser 直接在網頁(github, gitlab)上開啟目前的檔案  Vim 基本常用指令  多行修改: C_V 選取， I 進入修改模式 C_d 下滑一頁 C_b 上滑一頁 :set syn=yaml 設定語法高亮  Ref https://learnku.com/articles/24924 https://github.com/ycm-core/YouCompleteMe\n","id":13,"section":"posts","summary":"好文章推推，直接抄爆 https://learnku.com/articles/24924 設定開始 撰寫設定檔 首先 vim ~/.vimrc 改成下面這模樣 \u0026quot;============================================================================== \u0026quot; vim 内置配置 \u0026quot;============================================================================== \u0026quot; 设置 vimrc 修改保存后立刻生效，不用在重新打开 \u0026quot; 建议配置完成后将这","tags":["vim","golang"],"title":"我要裝 vim","uri":"https://blog.10oz.tw/20200926-wanna-install-vim/","year":"2020"},{"content":" 這次筆記內容會圍繞在比特幣這個區塊鍊加密貨幣系統 然後比特幣是一種讓北極熊沒有家住的技術 (?\n 區塊鏈的安全  區塊鏈鏈的模式，保證新的區塊接續前一個區塊，當區塊越多越難被修改 共識機制需要多數節點認同保護資料不易被竄改，也就是去中心化的部分啦 密碼學上的困難問題保護使用資產不會被任意取用，也在建立新的區塊時增加難度，就是挖礦的部分啦  共識機制 這是在分散式系統中相當常見的問題，當節點多了，在同步上出現分歧時應該要聽誰的? 究竟誰手中的資料才是正確的呢?\n拜占庭將軍問題 描述有數個將軍各自在不同地方，但有著相同的任務，而這個任務非常艱難，必須要每個將軍同時進攻、或是同時撤退，否則就會失敗。\n因此在出發之前，每位將軍會投票決定之後才開始行動， 然而\u0026hellip;在這樣的條件下，竟有還有幾位將軍是隱藏身分的間諜!?\n在節點中，同樣會遇到這樣的問題，當節點中出現了不遵守規定的惡意節點時，該如何將它的影響降低呢?\n挖礦 也就是增加難度，比特幣使用 PoW(Proof-of-Work)，讓北極熊沒地方住 ，讓每個節點用工作量來證明自己。如果你想要搞破壞的話，你必須付出比整個鏈上過半的計算能力，然而在現在廣大的比特鏈生態來說，這是不可能的。\n 每個鏈上的共識機制都不同，例如乙太鍊上使用的是 PoS\n 激勵機制 在前一個段落的區塊鍊安全那邊有說到使用 PoW 來保證難以隨意的添加區塊，但是認真想想誰要做這麼吃力的事情? 因此激勵機制的部分就是 給你錢幫我算 (*´∀`)~♥ xdd\n區塊鏈節點 身為一個去中心化的點對點系統，當然一定要有節點。在比特鏈上可以大致分兩種節點，全節點(Full Node)與輕量節點(Light Node)\n 全節點: 存放著完整的比特鏈資訊(好幾十GB)，工作是打包區塊上鏈以及驗證其他人上傳區塊的合法性 輕量節點: 也稱為簡單支付驗證（SPV）節點，不需要儲存所有區塊資訊，也不會對鏈上的安全性做出貢獻，就只是個 read user。可以是手機或是電腦的客戶端軟體，他能夠驗證某一筆交易是否在區塊鏈中 礦工仔: 準確來說礦工不一定是比特網路的一部分，礦工只需要向全節點要求交易回來打包、計算，再將節點廣播出去給所有的全節點驗證就好了  挖礦仔常見問題  Q: 挖礦是啥米?\n 當有一筆交易要進行的時候，交易方拋出他的交易資訊，請人幫他簽核，成功幫他完成任務的人會有獎金\n Q: 這個簽核任務有是啥米?\n 礦工們會將交易區塊資訊 + Nonce 拿去 hash，不斷的替換 Nonce 取得某一組 hash 值開頭是 n 個 bits 為 0 的解答，第一個拿到解答的就是這次挖礦的成功者。因此越多人參與解題就越難挖到礦\n Q: 這樣不就超難挖礦的嗎?\n 每經過 2016 個交易認證後難度會改變(要求開頭的 0 變多個或變少)，改變依照之前的交易認證時間，如果太久就變簡單一點，反之亦然。\n Q: 挖礦挖不完的嗎?\n 會挖完的，最一開始驗證一筆交易礦工可以拿到 50 塊錢比特幣，每次產生出 21萬塊錢比特幣後，獎勵就會少一半，直到最後小於比特幣可以支付的最小單位 (10的-8次方比特幣)\n交易模型 UTXO Model (Unspent Transaction Output)，在比特幣鏈上的餘額並不是直接儲存一個數字的，如果你今天想要拿到某個地址的餘額的話，就需要從第一個區塊開始看，把每一筆還沒有被消費掉的交易(Unspent Transaction)加起來，這個數字才會是你的餘額。 例如說:\nA 轉給 C 100 btc .... (tx1) B 轉給 C 120 btc .... (tx2) 到這裡 C 有 2 筆未使用交易，總共 220 btc 如果 C 要轉給 A 130 塊錢的話，就必須從他的 UTXO 裡面選出來交易 C -\u0026gt; A 130 btc .... (tx3) C -\u0026gt; C 90 btc .... (tx4) 多餘的錢錢要還給自己呀！ 因此最後的結果中，C 消耗了 tx1, tx2 C 剩下一筆 90 塊的未使用交易  粉塵攻擊 在 UTXO 系統中會遇到的身分問題，可以參考這篇寫得很棒 XDD https://iview.sina.com.tw/post/23868182\n 在區塊上的交易紀錄基本上都是公開透明的，可以共大眾來查找。\n公有鏈：完全去中心化，也就是完全公開透明、任何人都可以加入，每個人都可以讀取上面的資料的鏈。 私有鏈：部分去中心化，是完全私有的區塊鏈，寫入權限全被一處中心所把持，而讀取權限則被這處中心限制，但此鏈交易速度比較快並且也保持了不可篡改性，是給私有公司使用的鏈。 聯盟鏈：介於公有鏈和私有鏈之間，和私有鏈最大的不同是，它適用於多個機構共同使用，或者一整個行業、聯盟用的；而私有鏈是一家企業或公司用的\nMerkle Tree 不可修改性 如果今天有人想要修改一個區塊的交易紀錄，會需要把後續所有的 Block 都修改才行，\n用於快速驗證交易存在某個區塊\n BIP (Bitcoin Improvement Proposals) BIP-32 HD-Wallet 定義 Hierarchical Deterministic wallet，可以由一個 Seed 來產生多組錢包地址(包含公鑰、私鑰) 好處是只需要記得 Seed 就可以動態錢包，不需要記得很長的密碼\nBIP-39 助記詞 助記詞(mnemonic)將 Seed 用英文單字來編碼表示，更方便記憶。 做法是 seed + checkSum 然後每 11bits 兌換呈一個對應的字\nBIP-44 多帳號的 HD-Wallet 基於 BIP-32 的系統，讓他同時支援多種幣別， 而一組助記詞可以產出 N 組私鑰，每組私鑰對應一種幣種(BTC, ETH\u0026hellip;) 表示形式像是:\nm / purpose' / coin_type' / account' / change / address_index  每個欄位有不同意義 - purpose' 固定寫 44 表示是依照 BIP-44 規則產生後面的樹跟子節點 - coin_type' 一組 Seed 可以為不同幣別產生多個完全獨立的錢包地址，例如比特幣是 0，以太幣是 60 \u0026raquo;\u0026gt; 這邊有列表 - account' 一組 Seed 可以為不同帳號產生多個完全獨立的錢包地址 - change' 固定用 0 表示外部鍊(external chain) 用於對外部收款付款， 1 表示內部鍊(internal chain)，這什麼意思\u0026hellip;我看不懂QQ - index' 剛剛說了麻，一個 Seed 可以產很多地址，index 表示你要第幾個錢包地址\n   coin account chain address path     Bitcoin first external first m / 44' / 0' / 0' / 0 / 0   Bitcoin Testnet first external first m / 44' / 1' / 0' / 0 / 0    可以到這個網站上實際產生一組試試看 https://iancoleman.io/bip39/\n錢包地址 比特幣錢包地址可能是 1, 3, bc1 開頭，測試鏈上的地址是 m, n, 2, tb1 開頭\n交易 有分幾種交易簽章模式，差別在如何使用 tx out，每個 tx out 上都有不同的 lock script，可以把這個鎖想像成是一個題目，你必須將題目完整解鎖你才有資格，例如說 lock script 是 + 3 = 5，那你 tx in 的 unlock script 就要是 2，組合起來驗證 2 + 3 = 5 這樣才是一個合法的交易簽章\n主要分成幾種模式：\nP2PKH (Pay to Pubkey Hash) 算是最基礎的模式，使用的 lock script 是\nOP_DUP OP_HASH160 \u0026lt;Public Key Hash\u0026gt; OP_EQUAL OP_CHECKSIG  unlock script\n\u0026lt;Signature\u0026gt; \u0026lt;Public Key\u0026gt;  P2SH (Pay to Script Hash) 在這之前要先認識一下多簽 (Multi-signature)，他的 lock script 是由多個公鑰組成，你必須完成他指定數量的簽章才能解鎖，\n例如說 2-3 多簽，就是你必須要有這 3 個人其中兩個的簽章\n2 \u0026lt;Public Key A\u0026gt; \u0026lt;Public Key B\u0026gt; \u0026lt;Public Key C\u0026gt; 3 OP_CHECKMULTISIG  假設你有 B, C 的同意， unlock script 會像是\nOP_0 \u0026lt;Signature B\u0026gt; \u0026lt;Signature C\u0026gt;  不過，這樣的方式如果人數一多會讓 lock script 變得非常非常長，這樣儲存 UTXO 會浪費掉很多珍貴的記憶體，因此 P2SH 來解決問題惹，簡單來說就是把題目放到 lock script，而 unlock script 只存題目的 hash，驗證時首先驗證 lock script 裡面的題目 hash 後是否和 unlock script 相同，相同的話就相信你並接收你的驗證\nlock script, 裡面的 redeem scriptHash 就是題目的 hash，\nredeem script(題目): 2 PKA PKB PKC 3 OP_CHECKMULTISIG\nOP_HASH160 \u0026lt;redeem scriptHash\u0026gt; OP_EQUAL  unlock script 比較一下前面的多簽\n\u0026lt;SigB\u0026gt; \u0026lt;SigC\u0026gt; 2 PKA PKB PKC 3 OP_CHECKMULTISIG  example: P2WPKH ( pay to witness public key hash) SegWit (Segregated Witness) 隔離見證 由於每個區塊最多最多只能夠有 1MB，而每一筆交易的簽章佔用了很大的比例， 因此在 BIP141 提出了見證隔離這個方案，將原本一個區塊的最大值從 1MB 改成 4MB，計算單位從 bytes 改成 weight，並將原本簽章的部份抽出來存放，這表示發一筆交易需要的 byte 更少更便宜，經過計算後一個區塊能夠放更多的交易，因此交易速度提高，而礦工打包區塊也可以拿到更多手續費，\nBech32 encoded segwit addresses start with a human-readable\n 帳號安全 橢圓曲線用的是這條 secp256k1，他長這樣\nsecp256k1.P = fromHex(\u0026quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\u0026quot;) secp256k1.N = fromHex(\u0026quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\u0026quot;) secp256k1.B = fromHex(\u0026quot;0000000000000000000000000000000000000000000000000000000000000007\u0026quot;) secp256k1.Gx = fromHex(\u0026quot;79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\u0026quot;) secp256k1.Gy = fromHex(\u0026quot;483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\u0026quot;)  比特幣錢包地址怎麼來的呢?\n  把公鑰拿出來找到他在曲線上的 (x, y)，再拿去 hash 2 次， 再將 hash 結果做兩次 sha256 取得前四個 byte 作為 checkSum 最後 base58 encode 就是人類看到的地址囉  hash = ripemd160(sha256(pubkey_bits)) checkSum = sha256(sha256(\u0026ldquo;00\u0026rdquo;+hash))[:4] // (0x00 for Main Network) addr = base58(hash + checkSum) 詳細可以參考這篇wiki\n 以太幣錢包的話有點不同\n 把公鑰拿出來後用的是 Keccak-256(sha-3) 來 hash，特點是長度是不固定的 最後加上 EIP55 的大小寫檢查碼 (這是可選的) 詳細可以參考這個 https://git.io/ethAddressHash\n Ref 什麼是節點 https://academy.binance.com/zt/articles/what-are-nodes https://medium.com/taipei-ethereum-meetup/%E8%99%9B%E6%93%AC%E8%B2%A8%E5%B9%A3%E9%8C%A2%E5%8C%85-%E5%BE%9E-bip32-bip39-bip44-%E5%88%B0-ethereum-hd-%EF%BD%97allet-a40b1c87c1f7 https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki 比特幣問題們 https://bitcoin.org/zh_TW/faq#wont-the-finite-amount-of-bitcoins-be-a-limitation 關於比特幣地址 https://medium.com/my-blockchain-development-daily-journey/%E9%97%9C%E6%96%BC%E6%AF%94%E7%89%B9%E5%B9%A3%E5%9C%B0%E5%9D%80-%E4%BD%A0%E8%A9%B2%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B-8dd3bbb89ade 隔離見證 https://blockcast.it/2017/04/24/what-is-scalability-issue-and-segregated-witness/ bitcoin tx怎麼包 https://medium.com/taipei-ethereum-meetup/mastering-bitcoin-ch5-transactions-38a387e3819a 比特節點介紹 https://academy.binance.com/zt/articles/what-are-nodes 註記詞與BIP https://www.mdeditor.tw/pl/pCPM/zh-tw\n","id":14,"section":"posts","summary":"這次筆記內容會圍繞在比特幣這個區塊鍊加密貨幣系統 然後比特幣是一種讓北極熊沒有家住的技術 (? 區塊鏈的安全 區塊鏈鏈的模式，保證新的區塊接續前一個區","tags":null,"title":"新米 blockchain 混亂中","uri":"https://blog.10oz.tw/20200919-blockchain-bitcoin-beginer/","year":"2020"},{"content":"wire 是個啥米 wire 是一個靜態的注入工具，不像是其他的注入工具(uber/fx, facebook/inject)使用 reflect 來達成，他選擇使用 gen code 的方式產生可以使用的注入程式碼。\n能夠在編譯階段將注入的動作完成，而不是在執行程式的當下才知道發生了什麼錯誤\n Q: Should I use Wire for small applications?\nProbably not. Wire is designed to automate more intricate setup code found in larger applications. For small applications, hand-wiring dependencies is simpler. 不複雜的小型專案還是手動注入會更乾淨喔~\n go build tag 菜鳥如我這時候才知道，在 .go 檔案最前面加入 build tag 的檔案，在編譯的時候是不會被加進去的(ex: //+build foo ) 所以可以放重複的 function 在同一個 package 裡面，這個操作在 lorca 那篇也有出現過，可以交叉比較一下～\n這是一個 wire.go 檔案\n//+build wireinject package main import ( \u0026quot;learnGo/wire/repo\u0026quot; \u0026quot;learnGo/wire/service\u0026quot; \u0026quot;github.com/google/wire\u0026quot; ) func CreateService() (service.Service, error) { wire.Build(repo.NewRepo, service.NewService) panic(\u0026quot;never be triggered\u0026quot;) return nil, nil }  這是一個 wire_gen.go 檔案，他們在同一個 pakcage 下，定義著相同的函式，但是編譯的時候只會看 wire_gen.go，因為 wire.go 的最前面有標記 build tag\n// Code generated by Wire. DO NOT EDIT. //go:generate wire //+build !wireinject package main import ( \u0026quot;learnGo/wire/repo\u0026quot; \u0026quot;learnGo/wire/service\u0026quot; ) import ( _ \u0026quot;github.com/google/wire\u0026quot; ) // Injectors from wire.go: func CreateService() (service.Service, error) { repoRepo := repo.NewRepo() serviceService := service.NewService(repoRepo) return serviceService, nil }  假設我們有個 main.go 來執行\u0026hellip;\npackage main import ( _ \u0026quot;github.com/google/wire\u0026quot; ) func main() { svc, err := CreateService() if err != nil { panic(err) } svc.SayHello(\u0026quot;wire main package\u0026quot;) }  執行 go build -tags wireinject 這樣會使用 wire.go 來編譯，長出來的執行檔就會跑 wire.go:14 的 panic\n根據這樣的經驗，進階可以利用 golang build tag 的功能，依照不同的需求來編譯出不同的執行檔\n 踩到坑: 如果用 go run *.go 來跑，那麼你會得到 {function} redeclared in this block，你的所有檔案還是會被拿來用QQ\n Wire 的使用方法 使用上一段落的範例， wire_gen.go 是怎麼長出來的呢？ 首先需要安裝 wire\ngo get github.com/google/wire/cmd/wire  然後輸入\nwire  就可以看見 wire_gen.go 長出來囉\n詳細看一下內容的前幾行，\n// 提醒你和編譯器這是一個產生出來的檔案，不是給人類直接修改的 // Code generated by Wire. DO NOT EDIT. // 可以使用 `go generate` 指令來觸發後面的指令， // 在這裡會幫你跑 wire 來 gen code //go:generate wire // 註記 build tags 不存在 wireinject 用的 //+build !wireinject // ...  注入 Interface 在 github 的 document guide 上有寫，很實用也寫一份易讀版\n 任務: repo.NewRepo 回傳 *repo.DefaultRepo (他實作 repo.Repoer) svc.NewService 需要一個 repo.Repoer 因此我們需要多做一層將 pointer 轉成 interface\n // Repo ... type Repoer interface { // } // NewRepo ... func NewRepo(cfg *config.Config) *DefultRepo { return \u0026amp;DefultRepo{ Prefix: cfg.DBCfg.Prefix, } } // NewService ... func NewService(repo repo.Repoer) *DefultService { return \u0026amp;DefultService{ repo: repo, } } var Set = wire.NewSet( // 產生 *DefaultRepo repo.NewRepo, // 將 *DefaultRepo 轉成 Repoer wire.Bind(new(repo.Repo), new(*repo.DefultRepo)), // 注入需要 Repoer service.NewService, )  Ref https://medium.com/@dche423/master-wire-cn-d57de86caa1b https://github.com/google/wire/blob/main/docs/guide.md\n","id":15,"section":"posts","summary":"wire 是個啥米 wire 是一個靜態的注入工具，不像是其他的注入工具(uber/fx, facebook/inject)使用 reflect 來達成，他選擇使用 gen code 的方式產","tags":["golang","di","wire"],"title":"golang 注入工具 wire","uri":"https://blog.10oz.tw/20200908-golang-di-tool-wire/","year":"2020"},{"content":"介紹 GitHub 在 2018 年推出的短網址服務: git.io\n他可以把 GitHub 的網址縮短~\nwith fish 其實會發現他的原因，是因為在尋找 fish 的 plugin\nhttps://github.com/jorgebucaran/gitio.fish\nfisher 是一個 fish 的套件管理工具，我們用它來安裝 fish 版 gitio\nfisher add jorgebucaran/gitio.fish  用這個工具的話可以自定義名稱喔！ 網頁版的 UI 好像就沒有這個選項 QQ\n安裝完成後 gitio key=url 就可以了\ngitio yamcha=https://github.com/XiaoXiaoSN/YamCha # https://git.io/yamcha  without fish? 直接自己組 queryString 打過去也是可以的\nexport url=https://github.com/XiaoXiaoSN/YamCha export code=yamcha curl https://git.io/ --data-urlencode \u0026quot;url=$url\u0026quot; --data-urlencode code=\u0026quot;$code\u0026quot;  ","id":16,"section":"posts","summary":"介紹 GitHub 在 2018 年推出的短網址服務: git.io 他可以把 GitHub 的網址縮短~ with fish 其實會發現他的原因，是因為在尋找 fish 的 plugin https://github.com/jorgebucaran/gitio.fish fisher 是一個 fish 的套件管理工具，我們用它來安裝 fish","tags":[],"title":"已知用火 - git.io 短網址","uri":"https://blog.10oz.tw/20200831-known-fire-gitio/","year":"2020"},{"content":"環境 我們先用 macOS Catalina 10.15.2 來做筆記喔\n1. 虛擬機 一開始當然是虛擬機啦，讓我們用 vagrant 搭配 virtual box 吧～\n1.1 安裝 vagrant 跟 virtual box brew cask install vagrant vagrant version  vagrant 使用版本 2.2.10\n支援的 virtual box 版本沒有到最新的 6， 我們到這邊下載舊版吧\nhttps://www.virtualbox.org/wiki/\n 如果 mac 不給你開的話，記得可以到 系統偏好設定 \u0026gt; 安全性與隱私 \u0026gt; 一般 開啟權限\n 1.2 設定 vagrant 第一步要先建立一個 Vagrantfile，我們選用 ubuntu 16.04 TLS\n這邊也有更多選擇 \u0026ndash;\u0026gt; https://app.vagrantup.com/boxes/search\n# 先在你喜歡的地方開個資料夾吧 mkdir -p ~/projects/vagrant/k8s-master cd ~/projects/vagrant/k8s-master vim Vagrantfile  # -*- mode: ruby -*- # vi: set ft=ruby : Vagrant.configure(2) do |config| # 選用的檔案，xenial 是 ubuntu16 的名字 config.vm.box = \u0026quot;ubuntu/xenial64\u0026quot; # 將虛擬機內部的 6443 port 導出到本機的 26443 port # config.vm.network \u0026quot;forwarded_port\u0026quot;, guest: 6443, host: 26443 config.vm.network \u0026quot;private_network\u0026quot;, ip: \u0026quot;172.16.16.100\u0026quot; # 分配 2GB 的記憶體給虛擬機 config.vm.provider \u0026quot;virtualbox\u0026quot; do |vb| v.name = \u0026quot;k8s-m1\u0026quot; vb.memory = 2048 vb.cpus = 2 end # 設定帳號密碼是 ubuntu:ubuntu config.vm.provision 'shell', inline: \u0026lt;\u0026lt;-SHELL echo 'ubuntu:ubuntu' | sudo chpasswd SHELL end  1.3 用 vagrant 啟動虛擬機 設定好後就開起來連進去吧\nvagrant up vagrant ssh  2. 安裝 kubernates server 2.1 安裝 container 服務 最重要的，我們要先裝 docker \u0026raquo; 我是指南\n## 進入 super user 模式來安裝 sudo su ## 以下開始安裝 Docker CE ## Set up the repository: ## Install packages to allow apt to use a repository over HTTPS apt-get update -y \u0026amp;\u0026amp; apt-get install -y \\ apt-transport-https ca-certificates curl software-properties-common ## Add Docker’s official GPG key curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add - ## Add Docker apt repository. add-apt-repository \\ \u0026quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable\u0026quot; ## Install Docker CE. apt-get update -y \u0026amp;\u0026amp; apt-get install -y \\ containerd.io=1.2.10-3 \\ docker-ce=5:19.03.4~3-0~ubuntu-$(lsb_release -cs) \\ docker-ce-cli=5:19.03.4~3-0~ubuntu-$(lsb_release -cs) ## Setup daemon. cat \u0026gt; /etc/docker/daemon.json \u0026lt;\u0026lt;EOF { \u0026quot;exec-opts\u0026quot;: [\u0026quot;native.cgroupdriver=systemd\u0026quot;], \u0026quot;log-driver\u0026quot;: \u0026quot;json-file\u0026quot;, \u0026quot;log-opts\u0026quot;: { \u0026quot;max-size\u0026quot;: \u0026quot;100m\u0026quot; }, \u0026quot;storage-driver\u0026quot;: \u0026quot;overlay2\u0026quot; } EOF mkdir -p /etc/systemd/system/docker.service.d # Restart docker. systemctl daemon-reload systemctl restart docker # If you want the docker service to start on boot, run the following command: sudo systemctl enable docker  2.2 安裝 kubernates 我們需要 kubelet、 kubeadm 和 kubectl \u0026raquo; 指南\nsudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -y apt-transport-https curl curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add - cat \u0026lt;\u0026lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list deb https://apt.kubernetes.io/ kubernetes-xenial main EOF sudo apt-get update sudo apt-get install -y kubelet kubeadm kubectl sudo apt-mark hold kubelet kubeadm kubectl  # 禁用 swap swapoff -a; sed -i '/swap/d' /etc/fstab # 更改網路設定 cat \u0026gt;\u0026gt;/etc/sysctl.d/kubernetes.conf\u0026lt;\u0026lt;EOF net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system  2.3 kubernates master 之 kubeadm 連線回來後記得切換回 super user\nvagrant ssh # 這時候可以看到 hostname 已經變成 k8s-m1 sudo su  這邊簡單選用默認的 Flannel 實作 pod 與 pod 間溝通的介面~\n kubeadm only supports Container Network Interface (CNI) based networks\n kubeadm init \\ --apiserver-advertise-address=172.16.16.100 \\ --pod-network-cidr=172.16.0.0/16  等待個 2~3 分鐘\n成功後會提示你以下訊息！ 就表示成功了\nYour Kubernetes control-plane has initialized successfully! ## 讓 user 可以連線到 k8s cluster To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config You should now deploy a pod network to the cluster. Run \u0026quot;kubectl apply -f [podnetwork].yaml\u0026quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ ## 加入 node 到 cluster，複製起來晚點開好其他 node 後要用 Then you can join any number of worker nodes by running the following on each as root: kubeadm join 10.0.2.15:6443 --token 3vex22.6kqkhji310d3ckp0 \\ --discovery-token-ca-cert-hash sha256:cb8bb2fde074ba2a294413122a5a9208479b12a73ec316c01bd9a8b485add2fa  先跑個他提示的訊息，讓 user 可以連線到 cluster\nmkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config  2.4 安裝 kubenetes 網路介面 接下來要為我們的 k8s cluster 建立 pod network，他的工作是負責跟 Container 連線，他們各自有實作 CNI( Container Network Interface)，詳細可以來參考Kubernetes網絡模型列表\n這裡我們選擇官方偷偷推薦的 Calico (CentOS 的 Flannel 也很多人用)\nkubectl create -f https://docs.projectcalico.org/v3.14/manifests/calico.yaml  2.5 image 存起來才可以複製好多個 回到本地端 vagrant 的資料夾，把目前的狀態打包起來\n給想要有很多台 master 的你~~\nvagrant package --output k8s-master.box  2.6 讓 master 可以用於部署 在預設情況下，為了安全和穩定性，master node 會被隔離開來，不允許部署 Pod 上去\n但是如果你要做單節點的話~~\nkubectl taint nodes --all node-role.kubernetes.io/master-  3. 安裝 kubernates worker 3.1 Vagrant 啟動檔案 # -*- mode: ruby -*- # vi: set ft=ruby : Vagrant.configure(2) do |config| NodeCount = 4 (1..NodeCount).each do |i| config.vm.define \u0026quot;k8s-w#{i}\u0026quot; do |node| node.vm.box = \u0026quot;ubuntu/xenial64\u0026quot; node.vm.hostname = \u0026quot;k8s-w#{i}\u0026quot; node.vm.network \u0026quot;private_network\u0026quot;, ip: \u0026quot;172.16.16.10#{i}\u0026quot; node.vm.provider \u0026quot;virtualbox\u0026quot; do |v| v.name = \u0026quot;k8s-w#{i}\u0026quot; v.memory = 2048 v.cpus = 1 end node.vm.provision 'shell', inline: \u0026lt;\u0026lt;-SHELL echo 'ubuntu:ubuntu' | sudo chpasswd SHELL end end end  3.2 安裝步驟 2.1 2.2\n vagrant 開多台vm時，連線回去要加上名字:\nvagrant ssh k8s-w1\n 3.3 加入 kubernates cluster 到 master 機器上拿到加入 cluster 的指令\nkubeadm token create --print-join-command  再回來 worker 機器上，使用 sudo 加入節點後貼上剛才拿到的指令\nsudo su kubeadm join 172.16.16.100:6443 --token 7fz9ob.a6sno93d0zwcz3v9 --discovery-token-ca-cert-hash sha256:cb8bb2fde074ba2a294413122a5a9208479b12a73ec316c01bd9a8b485add2fa  回到 master\nkubectl get nodes  以上 k8s 架設就大功告成了，把 master 的 ~/.kube/config 複製一份回到本地端就可以用 local 端拜訪囉~\nReference https://rickhw.github.io/2019/03/17/Container/Install-K8s-with-Kubeadm/ https://zhuanlan.zhihu.com/p/31398416 https://www.vagrantup.com/docs/providers/virtualbox https://www.youtube.com/watch?v=mMmxMoprxiY 更換 master IP https://github.com/kubernetes/kubeadm/issues/338\n","id":17,"section":"posts","summary":"環境 我們先用 macOS Catalina 10.15.2 來做筆記喔 1. 虛擬機 一開始當然是虛擬機啦，讓我們用 vagrant 搭配 virtual box 吧～ 1.1 安裝 vagrant 跟 virtual box brew cask install vagrant vagrant version vagrant 使用版本 2.2.10 支援的 virtual box 版本沒有到最","tags":["kubernetes","vm","vagrant"],"title":"我們想在虛擬機上跑個 K8s","uri":"https://blog.10oz.tw/20200830-run-kubernetes-on-vm/","year":"2020"},{"content":"問題起源 看看人家，一個 latest 有這麼多種架構的版本 羨慕耶 我也想要編一個給我的樹莓派 執行環境  » docker version Client: Docker Engine - Community Version: 19.03.12 API version: 1.40 Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:41:33 2020 OS/Arch: darwin/amd64 Experimental: true Server: Docker Engine - Community Engine: Version: 19.03.12 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:49:27 2020 OS/Arch: linux/amd64 Experimental: true containerd: Version: v1.2.13 GitCommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: Version: 1.0.0-rc10 GitCommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init: Version: 0.18.0 GitCommit: fec3683  開始正題 (buildx 快速版) 這是實驗性功能~ Mac \u0026amp; Windows 請進，linux 先來這看看 \u0026gt; https://github.com/docker/buildx ，或是下滑懷舊版\n設定環節 首先我們要開啟 docker 實驗功能 vim ~/.docker/config.json 加上 16 行的 experimental: \u0026quot;enabled\u0026quot;\n{ \u0026quot;auths\u0026quot;: { \u0026quot;474872403908.dkr.ecr.us-east-1.amazonaws.com\u0026quot;: {}, \u0026quot;917719776018.dkr.ecr.ap-northeast-1.amazonaws.com\u0026quot;: {}, \u0026quot;https://917719776018.dkr.ecr.ap-northeast-1.amazonaws.com\u0026quot;: {}, \u0026quot;https://index.docker.io/v1/\u0026quot;: {}, \u0026quot;https://registry.tenoz.tw\u0026quot;: {}, \u0026quot;registry.heroku.com\u0026quot;: {}, \u0026quot;registry.tenoz.tw\u0026quot;: {} }, \u0026quot;HttpHeaders\u0026quot;: { \u0026quot;User-Agent\u0026quot;: \u0026quot;Docker-Client/19.03.1 (darwin)\u0026quot; }, \u0026quot;credsStore\u0026quot;: \u0026quot;desktop\u0026quot;, \u0026quot;stackOrchestrator\u0026quot;: \u0026quot;swarm\u0026quot;, \u0026quot;experimental\u0026quot;: \u0026quot;enabled\u0026quot;, \u0026quot;debug\u0026quot;: true }  這樣就可以下指令查看 image 的相關資料 docker manifest inspect --verbose xiao4011/toolbox:latest 再來下個指令看看別人的多架構版 docker manifest inspect --verbose redis:latest 一看不得了，人家是 array 阿！！ 帥吧\n編譯 Image 拿出你的 Dockerfile 在 From 前面加上你要執行的 target 像這樣 --platform=$TARGETPLATFORM\n# Build code FROM --platform=$TARGETPLATFORM golang:alpine as builder ENV GO111MODULE=on WORKDIR /app COPY . . RUN apk add --update git ca-certificates RUN go mod download RUN go build -o app . # pull the binary file and service work really in the layer FROM --platform=$TARGETPLATFORM alpine:latest WORKDIR /srv/application COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ COPY --from=builder /app/app /srv/application/toolbox COPY --from=builder /app/public /srv/application/public ENTRYPOINT [\u0026quot;./toolbox\u0026quot;]  改好了之後呢 編譯給他跑下去，可以選擇幾個你喜歡的 \u0026ndash;platform 內容來跑\ndocker buildx build \\ --push \\ --platform linux/amd64,linux/arm64,linux/arm/v7,linux/arm/v6 --tag xiao4011/toolbox:latest .  如果不知道你的環境有什麼 platform 可以編譯的話 可以輸入docker buildx inspect --bootstrap 因為我們有加上 --push 所以直接出發到 docker hub 上面看一下狀況 直接完成，484很快～ 開始正題 (懷舊版) 方法是利用 docker manifest 將多個 docker images 整合在一起 因此首先我們要準備編譯多個 images\n編譯 Images  方法1： 指定架構拉取 image 這個方法是建立在別人的 mutli-arch image 上的，用不同架構直接來編譯  # 編譯 amd64 架構 docker build --platform linux/amd64 --pull . -t xiao4011/toolbox:amd64 docker push xiao4011/toolbox:amd64 # 編譯 armv7 架構 docker build --platform linux/arm/v7 --pull . -t xiao4011/toolbox:armv7 docker push xiao4011/toolbox:armv7   方法2： 手動更換編譯平台架構 image 在 Dockerfile 中加入 ARG ARCH 加入一個編譯變數叫做 ARCH 來指定編譯的架構  ARG ARCH FROM $ARCH/golang:alpine as builder // 更多操作 dockerfile...  # 執行編譯 export ARCH=arm32v7; docker build --build-arg ARCH=$ARCH . -t xiao4011/toolbox:$ARCH docker push xiao4011/toolbox:$ARCH  包裝 manifest 檔案 發出去~~\ndocker manifest create xiao4011/toolbox:manifest \\ --amend xiao4011/toolbox:amd64 \\ --amend xiao4011/toolbox:armv7 docker manifest push xiao4011/toolbox:manifest  一言不合就 CI/CD (example for buildx) 更新 images 這種事情當然要自動化一下啊！這次跟著 docker 官方介紹第一次認識了 github actions，他是 github 內建的 pipeline 工具 有個有趣的地方是可以插入別人寫的 actions，幾乎每個步驟都有人給你包好了，只要 call function 就對了\n首先我們建立檔案 vim .github/workflows/cicd.yml\n# .github/workflows/cicd.yml name: build our image on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: - name: install Go uses: actions/setup-go@v1 with: go-version: ${{ matrix.go-version }} - name: check out path uses: actions/checkout@v2 - name: testing run: go test ./... - name: install buildx id: buildx uses: crazy-max/ghaction-docker-buildx@v1 with: version: latest - name: login to docker hub run: echo \u0026quot;${{ secrets.DOCKER_PASSWORD }}\u0026quot; | docker login -u \u0026quot;${{ secrets.DOCKER_USERNAME }}\u0026quot; --password-stdin - name: build the image run: | docker buildx build \\ --push \\ --tag xiao4011/toolbox:latest \\ --platform linux/amd64,linux/arm64,linux/arm/v7,linux/arm/v6 .  接下來要去 github 設定 Secrets，開啟專案頁面後選擇 Setting \u0026gt; Secrets 選擇 New secret 加入 docker 的帳號密碼，等一下 pipeline 在 push image 的時候會使用到\n 也可以額外設定除錯模式 ACTIONS_RUNNER_DEBUG=true ACTIONS_STEP_DEBUG=true\n Ref https://www.docker.com/blog/multi-arch-build-and-images-the-simple-way/\nhttps://hub.docker.com/r/ckulka/multi-arch-example\nhttps://docs.docker.com/buildx/working-with-buildx/\n","id":18,"section":"posts","summary":"問題起源 看看人家，一個 latest 有這麼多種架構的版本 羨慕耶 我也想要編一個給我的樹莓派 執行環境 » docker version Client: Docker Engine - Community Version: 19.03.12 API version: 1.40 Go version: go1.13.10 Git commit: 48a66213fe Built: Mon Jun 22 15:41:33 2020 OS/Arch: darwin/amd64 Experimental:","tags":["docker","multi-arch","buildx"],"title":"Docker 建立不同架構的 Image","uri":"https://blog.10oz.tw/20200814-docker-mutli-arch-image/","year":"2020"},{"content":"\n\nCasbin 是什麼 casbin 是一個權限控管的模組，可以定義不同的權限模型來管理使用者的權限，預設包含了很多知名的模型如 RBAC ABAC 他雖然規則複雜但他卻支持許多語言，可以在不同的環境下使用，包含 Go, Java, Node.js, php, python, c#, c++, rust\n所以學學看應該很不錯吧！\nModel, Policy 語法 開啟編輯器的畫面 https://casbin.org/editor/ 實際操作更好了解！\n首先要了解 Model, Policy 是什麼呢?\n  Policy 是規則，裡面寫了一系列的權限像是\n{小明} 可以對 {文件} {查看}\n{小明} 可以對 {程式} {查看}\n{小明} 可以對 {程式} {修改}\n  Model 是用來定義 Input 的格式， Policy 的格式， Policy 的使用方法 像是前面 Policy 的寫法就是在這裡來定義\n  Model 權限模組 r request_definition 用來表示輸入，例如說 r = sub, obj, act 就有 3 種輸入，分別表示Subject(人) Object(資源) 動作(Action)\np policy_definition 用來表示規則的形狀，等一下在設定 Policy 的時候就要按這這個規則 範例像是 p = sub, act 就可以設定只和人、動作有關的規則 (alice 可以 read) 也可以同時設定第二條 Policy 格式 p2 = sub, act, act2，就可以把更多的資訊納入規則的建立，前提當然你的 r(輸入)要有帶入 act2\ng (role_definition) 也就是 RBAC 裡面的 R(role)，可以想像成是一個群組(group)裡面有很多的人，當你定義該群組有什麼權限，那麼在該群組裡面的人也就同時擁有這些權限。\ne (policy_effect) 定義規則公式的結果，最常見的是 e = some(where (p.eft == allow)) 表示只要有一條 match 結果通過就通過了 !some(where (p.eft == deny)) 表示只要有一條沒有通過，那就不通過 這裡 casbin 還有預設一些函數可以使用，像是用 keyMatch 來比對， * 表示全過，或是進一步的 regexMatch，還有 eval 可以動態的輸入規則 甚至可以自己寫 function 綁定進去，非常有用！可以去官網看看 更多function\nm (matchers) 就是使用前面設定檔來寫規則公式的地方\n來看一個範例模型 ACL (Access Control List) 也就是白名單模式 看到 matchers 很明顯說明了，你的 sub, obj, act 人、物、動作 都要相同才會是 allow\n[request_definition] r = sub, obj, act [policy_definition] p = sub, obj, act [policy_effect] e = some(where (p.eft == allow)) [matchers] m = r.sub == p.sub \u0026amp;\u0026amp; r.obj == p.obj \u0026amp;\u0026amp; r.act == p.act  Policy 權限規則 定義好模型之後，還需要資料才可以開始跑，跟上面的 Model 模型可以搭配著看 這裏 Policy 的寫法需符合 model 裡面 p(policy_definition) 的規範\np, alice, data1, read p, bob, data2, write  來看扣 複製了範例的 RBAC 模式，可以在剛剛的 editor 上選擇 RBAC with resource roles 來看看執行結果是否相同\n這邊在看的時候可以先看 policy g 定義的 group，\n alice 是 admin\ndata1 是 data_group\ndata2 是 data_group\n然後 admin 可以 write data_group\n 這樣應該相當容易理解了～\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;github.com/casbin/casbin/v2\u0026quot; \u0026quot;github.com/casbin/casbin/v2/model\u0026quot; scas \u0026quot;github.com/qiangmzsx/string-adapter/v2\u0026quot; ) var modelStr = ` [request_definition] r = sub, obj, act [policy_definition] p = sub, obj, act [role_definition] g = _, _ g2 = _, _ [policy_effect] e = some(where (p.eft == allow)) [matchers] m = g(r.sub, p.sub) \u0026amp;\u0026amp; g2(r.obj, p.obj) \u0026amp;\u0026amp; r.act == p.act ` var policyStr = ` p, alice, data1, read p, bob, data2, write p, admin, data_group, write g, alice, admin g2, data1, data_group g2, data2, data_group ` func main() { // 設定 Model 模型 // 參考 https://casbin.org/docs/en/model-storage m, _ := model.NewModelFromString(modelStr) // 設定 Policy 具體規則 // 可以參考 https://casbin.org/docs/en/adapters p := scas.NewAdapter(policyStr) // 建立 Enforcer 需要輸入 Model 和 Policy // casbin 提供很多的 adapter 讓開發者用自己適合的方式填充資料 (file, db, redis, cloud...) // 範例選擇了最方便的直接讀文字 XDD enforcer, _ := casbin.NewEnforcer(m, p) // 實際測試時間: // 在 model [request_definition] 設定了三個變數輸入 sub, obj, act := \u0026quot;alice\u0026quot;, \u0026quot;data2\u0026quot;, \u0026quot;write\u0026quot; result, _ := enforcer.Enforce(sub, obj, act) fmt.Printf(\u0026quot;enforce1: %t\\n\u0026quot;, result) // true sub, obj, act = \u0026quot;alice\u0026quot;, \u0026quot;data2\u0026quot;, \u0026quot;read\u0026quot; result, _ = enforcer.Enforce(sub, obj, act) fmt.Printf(\u0026quot;enforce1: %t\\n\u0026quot;, result) // false (因為 admin 對 data_group 沒有 read) }   再來偷偷推薦每日一庫的 casbin 文章 https://darjun.github.io/2020/06/12/godailylib/casbin/ 裡面提到 ABAC（attribute base access list）模型的用法，相當有趣 需求是這樣的：\n 正常工作時間9:00-18:00所有人都可以讀寫data，其他時間只有數據所有者能讀寫。\n Model 如下\n[request_definition] r = sub, obj, act [policy_definition] p = sub, obj, act [matchers] m = r.sub.Hour \u0026gt;= 9 \u0026amp;\u0026amp; r.sub.Hour \u0026lt; 18 || r.sub.Name == r.obj.Owner [policy_effect] e = some(where (p.eft == allow))  該規則不需要策略文件：\n存進去 SQL 裡面 實際上在使用 casbin 的時候我們不會用字串來寫 model, policy 更多會存在 file 或是 db 裡面，這時候 adapter 就派上用場啦~\npackage main import ( \u0026quot;fmt\u0026quot; \u0026quot;github.com/casbin/casbin/v2\u0026quot; xormadapter \u0026quot;github.com/casbin/xorm-adapter/v2\u0026quot; _ \u0026quot;github.com/lib/pq\u0026quot; ) func main() { // 初始化 xorm adpater，在這裡與 DB 連線 // 沒有指定 db 的話會幫你建立一個 casbin (加入 dbname=abc 可以指定使用 DB abc) // 進去會幫你檢查有沒有 casbin_rule 的資料表，沒有的話也會幫你加進去 driverName := \u0026quot;postgres\u0026quot; pgUser, pgPassWd := \u0026quot;root\u0026quot;, \u0026quot;root\u0026quot; dataSource := fmt.Sprintf(\u0026quot;user=%s password=%s host=127.0.0.1 port=5432 sslmode=disable\u0026quot;, pgUser, pgPassWd) a, _ := xormadapter.NewAdapter(driverName, dataSource) // Your driver and data source. // 直接讀檔案最快啦 enforcer, _ := casbin.NewEnforcer(\u0026quot;model_rbac.conf\u0026quot;, a) // 第一次跑的話會需要 Policy 資料，讓他幫忙寫進去吧 // enforcer.EnableAutoSave(false) // 關閉自動同步 { // 如果是 enforcer.AddPolicy 的話會幫你填第一個 \u0026quot;p\u0026quot; enforcer.AddNamedPolicy(\u0026quot;p\u0026quot;, \u0026quot;alice\u0026quot;, \u0026quot;data1\u0026quot;, \u0026quot;read\u0026quot;) enforcer.AddNamedPolicy(\u0026quot;p\u0026quot;, \u0026quot;bob\u0026quot;, \u0026quot;data2\u0026quot;, \u0026quot;write\u0026quot;) enforcer.AddNamedPolicy(\u0026quot;p\u0026quot;, \u0026quot;data_group_admin\u0026quot;, \u0026quot;data_group\u0026quot;, \u0026quot;write\u0026quot;) // enforcer.AddGroupingPolicies 的話會幫你填第一個 \u0026quot;g\u0026quot; enforcer.AddNamedGroupingPolicy(\u0026quot;g\u0026quot;, \u0026quot;alice\u0026quot;, \u0026quot;data_group_admin\u0026quot;) enforcer.AddNamedGroupingPolicy(\u0026quot;g2\u0026quot;, \u0026quot;data1\u0026quot;, \u0026quot;data_group\u0026quot;) enforcer.AddNamedGroupingPolicy(\u0026quot;g2\u0026quot;, \u0026quot;data2\u0026quot;, \u0026quot;data_group\u0026quot;) } // Load the policy from DB. enforcer.LoadPolicy() // 實際測試時間: // 在 model [request_definition] 設定了三個變數輸入 sub, obj, act := \u0026quot;alice\u0026quot;, \u0026quot;data2\u0026quot;, \u0026quot;write\u0026quot; result, _ := enforcer.Enforce(sub, obj, act) fmt.Printf(\u0026quot;enforce1: %t\\n\u0026quot;, result) // true sub, obj, act = \u0026quot;alice\u0026quot;, \u0026quot;data2\u0026quot;, \u0026quot;read\u0026quot; result, _ = enforcer.Enforce(sub, obj, act) fmt.Printf(\u0026quot;enforce2: %t\\n\u0026quot;, result) // false (因為 data_group_admin 對 data_group 沒有 read) }  Ref https://darjun.github.io/2020/06/12/godailylib/casbin/ https://github.com/casbin/xorm-adapter/tree/v2.0.1 https://casbin.org/docs/en/overview\n","id":19,"section":"posts","summary":"Casbin 是什麼 casbin 是一個權限控管的模組，可以定義不同的權限模型來管理使用者的權限，預設包含了很多知名的模型如 RBAC ABAC 他雖然規則複雜但他卻支持許多語言，可","tags":["golang","casbin"],"title":"Casbin 權限管理模組","uri":"https://blog.10oz.tw/20200813-casbin-the-access-control-model/","year":"2020"},{"content":"不囉唆直接上圖 馬上試試 pokesay\nbrew tap xiaoxiaosn/xiaoxiao brew install pokesay  起源 這個故事是這樣的，有一天發現了一個有趣的 command pokemonsay他是 cowsay 的改編版，它可以讓 pokemon 出現說你想要他說的話 XDD\n我用得很快樂的時候發現一件事很不快樂，當一行太多字的時候會換行\n你看！都擠在一起了 R\n這時我想到 cowsay 應該有這個功能才對呀！ 查詢了之後發現 在 pokemonsay 裡面 -n 被用在 Do not tell the pokémon name. 也就是最底下不要 show pokemon 的名字\nQQ 我不依，我自己改!\n介紹 Homebrew 首先先介紹一下 homebrew 這個軟體～ 他是 MacOS 上的套件管理工具，是 mac 最重要的必裝軟體之一\n brew 這個字是釀造的意思，homebrew 在家釀造也就是自釀的意思 tap 第三方套件的倉庫，就相當於是 apt 的 ppa 一樣的角色 formula 公式、配方，上面寫著軟體安裝的步驟，也就是釀製(brew)的方法 cellar 酒窖存放釀好的酒，預設存在 /usr/local/Cellar，每個資料夾裡面也存有不同的版本，當 brew switch 某個套件版本的時候就是把 /usr/local/bin 的 link 指過去    補充: brew cask 用來安裝 macOS apps 也就是可以直接在應用程式裡面看到的圖像化軟體，像是 Chrome, Firefox, 360Safe 之類的\n 了解完基本架構後，我們知道目標就是製作自己的 tap 好讓 brew 可以安裝我們釋出的第三方套件\n開始釀酒 我們分成兩個部分來完成，一個是我們的應用程式另一個是 homebrew 的安裝腳本\n程式本身 只要任何一個可以執行的命令都行，所以先不著墨於此 範例會用下面這個 repo，已經把我想要的 -n 指令加回來啦～～ https://github.com/XiaoXiaoSN/pokesay\nFormula 安裝指南 本文的重點來啦! 首先我們要到 github 上開一個新專案，命名叫做 homebrew-{your-tap-name}，例如我的 homebrew-xiaoxiao\n進入專案底下新增 Formula 資料夾，在底下新增你的 formula\n# Formula/pokesay.rb # 定義 Pokesay 繼承 Formula class Pokesay \u0026lt; Formula desc '\u0026quot;pokesay\u0026quot; is like \u0026quot;cowsay\u0026quot; but for pokémon.' homepage \u0026quot;https://github.com/XiaoXiaoSN/pokesay\u0026quot; # url 說明要去哪裡下載專案 # https://github.com/{username}/{repo}/{format}/{tag or branch} # format 我們都寫 tarball # tag or branch 就看你喜歡用哪個囉 url \u0026quot;https://github.com/XiaoXiaoSN/pokesay/tarball/v1.0.1\u0026quot; # sha256 用來確認你上面說的檔案身份，等等下面會說怎麼長出來 sha256 \u0026quot;43511be3dbb52b380bf7501e3b06a0a17ee0349d0246601537481ca811753a4a\u0026quot; # 版本號 version \u0026quot;v1.0.1\u0026quot; # depends_on 定義安裝你的東西前，會用到的依賴套件 depends_on \u0026quot;cowsay\u0026quot; =\u0026gt; :recommended depends_on \u0026quot;coreutils\u0026quot; =\u0026gt; [:recommended, \u0026quot;with-default-names\u0026quot;] if not OS.linux? # 定義安裝步驟 def install system \u0026quot;cp\u0026quot;, \u0026quot;-r\u0026quot;, \u0026quot;./cows\u0026quot;, \u0026quot;#{prefix}/cows\u0026quot; system \u0026quot;cp\u0026quot;, \u0026quot;pokemonsay.sh\u0026quot;, \u0026quot;pokesay\u0026quot; # 字串取代，讓 pokesay 在本地也可以找得到參考檔案 inreplace \u0026quot;pokesay\u0026quot;, /^pokemon_path=.*$/, \u0026quot;pokemon_path=#{prefix}/cows\u0026quot; # 把 pokesay 複製到這個 formula 的目錄 (/usr/local/Cellar/{pkg}/0.1/bin) # 並設定成可執行檔案 (chmod 0555 foo) bin.install \u0026quot;pokesay\u0026quot; end # 安裝完成後的驗證測試，這邊偷懶沒寫 XD test do system \u0026quot;false\u0026quot; end end  如何產生 sha256\n# 用 curl 下載壓縮檔下來， -L 跟隨跳轉 -o 儲存輸出到檔案 curl -L https://github.com/XiaoXiaoSN/pokesay/tarball/v1.0.1 -o pokesay.tar.gz # 計算 sha256 雜湊值 shasum -a 256 pokesay.tar.gz  brew edit brew edit 會叫出你安裝時下載的 Formula，讓你可以編輯再重新安裝\n也可以藉機偷偷參考別人的 Formula 是如何編寫的～～\nbrew edit wget # 會使用預設編輯器開啟  Ref homebrew 故事 https://www.onejar99.com/mac-homebrew-homebrew-cask-mac/ Formula-Cookbook https://docs.brew.sh/Formula-Cookbook\n","id":20,"section":"posts","summary":"不囉唆直接上圖 馬上試試 pokesay brew tap xiaoxiaosn/xiaoxiao brew install pokesay 起源 這個故事是這樣的，有一天發現了一個有趣的 command pokemonsay他是 cowsay 的改編版，它可以讓 pokemon 出現說你想要","tags":["homebrew","ruby","pokesay","pokemon"],"title":"Homebrew 自己寫配方一起來釀酒","uri":"https://blog.10oz.tw/20200811-homebrew-create-app/","year":"2020"},{"content":"步驟說明時間 確認 Windows 版本 首先按一下 Windows 鍵輸入 winver 來確認目前版本，版本必須是 19041 或是 2004 才可以喔 如果版本不夠的話，更新器下載 \u0026raquo; https://www.microsoft.com/en-us/software-download/windows10\n開啟環境設定 用系統管理員身分開啟 PowerShell 後，輸入指令開啟 Linux Subsystem 的支援和 HyperV 的虛擬機器平台 用 HyperV 要記得到 BIOS 開啟虛擬機器的支援喔\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart  這時候你需要重啟一下電腦~\n然後要更新 linux subsystem kernel https://docs.microsoft.com/nl-nl/windows/wsl/wsl2-kernel\n安裝 Linux 發行版 按一下 Windows 鍵輸入 Microsoft Store 後開啟商店選擇你要的 Linux 版本，在這裡我選擇 Ubuntu1804 另外偷偷下載了 windows terminal，有比較漂亮R 看一看 WSL2 的設定 更新完後開啟 PowerShell 將 WSL 預設版本改為 2\nwsl --set-default-version 2  可以用 wsl -l 來列出你的 Linux 們，把原本存在的 WSL 升級成 WSL2\nwsl --set-version Ubuntu-18.04 2  輸入 wsl -l -v 應該可以看見 Version 2，那這樣就對啦~ Docker Time 首先在 Win10 下載桌面版 Docker， https://docs.docker.com/docker-for-windows/wsl/\n下載好了嗎? 打開來選擇 WSL2 作為 backend 安裝好之後他會請你重新登入你的 Win10， 完成後選擇 Settings(上方的小齒輪) \u0026gt; General 來確認一下 Use the WSL2 based engine 選項 再來到 Resources \u0026gt; WSL Integartion，把你的 WSL linux 發行版選起來 點右下角的 Apply \u0026amp; Restart\n開啟你的 terminal，輸入 wsl -d \u0026lt;你的系統\u0026gt; 進入 WSL 的系統內 輸入 docker ps 確認有抓到 docker ~ 開個服務吧\n -d 在背景執行 -p port 導出 --name 幫 container 取名字  docker run -d -p 8080:80 --name docker_time docker/getting-started  看看你的 http://localhost:8080 服務開起來囉 測試完 docker 可以工作了，所以刪掉\ndocker kill docker_time  任性的個人化時間 # 更新一下 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y # git 設定 git config --global core.ignorecase false git config --global alias.co 'checkout' git config --global alias.chekcout 'checkout' git config --global alias.log1 'log --oneline -n 10' git config --global alias.logg 'log --oneline --graph' git config --global alias.cm 'commit -m' git config --global alias.cmamend '!git add $1 \u0026amp;\u0026amp; git commit --amend --no-edit' # shell 設定 sudo apt install fish -y curl -L https://get.oh-my.fish | fish omf install godfather # 開專案資料夾 mkdir projects ln -s (pwd)/projects ~/projects  Golang 環境 (gvm) 不囉嗦直接抄 \u0026raquo; https://blog.miniasp.com/post/2020/07/27/Build-Golang-Dev-Box-in-Windows?utm_source=Facebook_PicSee\nsudo apt install binutils bison gcc make build-essential -y curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer | bash -E source ~/.gvm/scripts/gvm set GOVER go1.14 gvm install go1.14 --binary gvm use go1.14 --default # 確認我們的工作~~ go version  紀錄一點問題  [time=Sat, Aug 8, 2020 1:07 PM]\n 開啟工作管理員時發現，有一個叫做 vmmem 的佔用了很多的 memory 和 CPU 發現很多人都有這樣的問題，紀錄一下解決方法 移駕到 c:\\users\\{{your profile name}} 開啟或新增 .wslconfig\n{%gist lewcianci/d09ef5e6741fe0eff61935d39e9667ee %}\n使用系統管理員身分開啟 PowerShell\nRestart-Service LxssManager  參考文章\n   MicroK8s Time (請勿參考) 直接遇到問題了，snapd 是不可用的狀態 sudo apt-get update \u0026amp;\u0026amp; sudo apt-get install -yqq daemonize dbus-user-session fontconfig sudo daemonize /usr/bin/unshare --fork --pid --mount-proc /lib/systemd/systemd --system-unit=basic.target exec sudo nsenter -t $(pidof systemd) -a su - $LOGNAME snap version  還需要開啟 Systemd 把這一段貼上去後關掉視窗重開\n## /etc/profile.d/00-wsl2-systemd.sh # Create the starting script for SystemD SYSTEMD_PID=$(ps -ef | grep '/lib/systemd/systemd --system-unit=basic.target$' | grep -v unshare | awk '{print $2}') if [ -z \u0026quot;$SYSTEMD_PID\u0026quot; ]; then sudo /usr/bin/daemonize /usr/bin/unshare --fork --pid --mount-proc /lib/systemd/systemd --system-unit=basic.target SYSTEMD_PID=$(ps -ef | grep '/lib/systemd/systemd --system-unit=basic.target$' | grep -v unshare | awk '{print $2}') fi if [ -n \u0026quot;$SYSTEMD_PID\u0026quot; ] \u0026amp;\u0026amp; [ \u0026quot;$SYSTEMD_PID\u0026quot; != \u0026quot;1\u0026quot; ]; then exec sudo /usr/bin/nsenter -t $SYSTEMD_PID -a su - $LOGNAME fi  好，問題解決來安裝吧\n# 安裝 microk8s sudo snap install microk8s --classic # 嘗試一下指令，他會提醒你要給權限照著做吧~記得要把 user 換掉喔 microk8s.status sudo usermod -a -G microk8s arios sudo chown -f -R arios ~/.kube  完成後離開重新登入，就可以開始開服務囉\nmicrok8s.enable dns dashboard  for Win10 2004 你各位阿~!這個中文輸入阿，很不ok阿 當輸入中文的時候需要切換成英文就會爆炸?\n往右下角的 中/A 點一下右鍵 一般 \u0026gt; 輸入設定 \u0026gt; \u0026ldquo;自動將中文模式中的按鍵順序切換為英數字元\u0026rdquo; 開起來 恩~是稍微好點了，不過這個選項也有毛病\u0026hellip;\u0026hellip; 你一按錯注音他給你改成英文阿QQ 哪個比較困擾需要個人評估了\nRef https://docs.microsoft.com/zh-tw/windows/wsl/install-win10\nhttps://pureinfotech.com/install-windows-subsystem-linux-2-windows-10/\nhttps://blog.miniasp.com/post/2020/07/26/Multiple-Linux-Dev-Environment-build-on-WSL-2\nhttps://docs.docker.com/docker-for-windows/wsl/\nhttps://github.com/microsoft/WSL/issues/5126#issuecomment-653715201\nhttps://wsl.dev/wsl2-microk8s\n","id":21,"section":"posts","summary":"步驟說明時間 確認 Windows 版本 首先按一下 Windows 鍵輸入 winver 來確認目前版本，版本必須是 19041 或是 2004 才可以喔 如果版本不夠的話，更新器下載 \u0026raquo; https://www.microsoft.com/en-us/software-download/windows10 開啟環境設定 用系統管理員","tags":["wsl2","windows"],"title":"出發尋找 WSL2 的旅程","uri":"https://blog.10oz.tw/20200728-journey-in-wsl2/","year":"2020"},{"content":"偶爾在 debug 的時候，看到的都是一整行實在不太快樂呀！\n我需要排版！！趕快筆記一下\n一、我有一個 struct stack overflow 上有重點！！ func prettyPrint(data interface{}) { jsonByte, err := json.MarshalIndent(data, \u0026quot;\u0026quot;, \u0026quot; \u0026quot;) if err != nil { fmt.Println(\u0026quot;\u0026quot;) } fmt.Printf(\u0026quot;%s\\n\u0026quot;, jsonByte) }  二、我有一個 json byte func prettyPrintByte(jsonByte []byte) { var buf bytes.Buffer err := json.Indent(\u0026amp;buf, jsonByte, \u0026quot;\u0026quot;, \u0026quot; \u0026quot;) if err == nil { jsonByte = buf.Bytes() } fmt.Printf(\u0026quot;%s\\n\u0026quot;, jsonByte) }  參考 https://stackoverflow.com/questions/19038598/how-can-i-pretty-print-json-using-go/42426889\n","id":22,"section":"posts","summary":"偶爾在 debug 的時候，看到的都是一整行實在不太快樂呀！ 我需要排版！！趕快筆記一下 一、我有一個 struct stack overflow 上有重點！！ func prettyPrint(data interface{}) { jsonByte, err := json.MarshalIndent(data, \u0026quot;\u0026quot;, \u0026quot; \u0026quot;) if err != nil { fmt.Println(\u0026quot;\u0026quot;) }","tags":["golang","json","pretty"],"title":"Golang 漂亮的輸出 JSON","uri":"https://blog.10oz.tw/20200229-golang-pretty-print/","year":"2020"},{"content":"json 格式簡單易讀，經常出現在各種 API、設定檔裡，golang 也有內建處理的 package，寫扣的時候也會經常遇到他喔，來筆記一下！ 內文會分成常用處理json、自定義處理 json和多層處理 三個 part， GOGO\n一、常用方法 package main import ( \u0026quot;encoding/json\u0026quot; \u0026quot;fmt\u0026quot; ) // Box 是個箱子 type Box struct { Name string `json:\u0026quot;name\u0026quot;` Color string `json:\u0026quot;color\u0026quot;` } func main() { jsonStr := ` { \u0026quot;name\u0026quot;: \u0026quot;喵喵\u0026quot;, \u0026quot;color\u0026quot;: \u0026quot;blue\u0026quot; }` box := new(Box) // 把 bytes 寫進去 Box 物件裡面 _ = json.Unmarshal([]byte(jsonStr), box) fmt.Printf(\u0026quot;%+v\\n\u0026quot;, box) // {Name:喵喵 Color:blue} // 再把物件寫回去 binary json box.Color = \u0026quot;黃色的\u0026quot; byteJSON, _ := json.Marshal(box) fmt.Printf(\u0026quot;%s\\n\u0026quot;, string(byteJSON)) // {\u0026quot;name\u0026quot;:\u0026quot;喵喵\u0026quot;,\u0026quot;color\u0026quot;:\u0026quot;黃色的\u0026quot;} }  二、更多方法 當我傻傻的以為，json 就這麼結束了的時候\n燈愣！！ 還有兩個 interface 可以實作\n// Unmarshaler is the interface implemented by types // that can unmarshal a JSON description of themselves. // The input can be assumed to be a valid encoding of // a JSON value. UnmarshalJSON must copy the JSON data // if it wishes to retain the data after returning. // // By convention, to approximate the behavior of Unmarshal itself, // Unmarshalers implement UnmarshalJSON([]byte(\u0026quot;null\u0026quot;)) as a no-op. type Unmarshaler interface { UnmarshalJSON([]byte) error } // Marshaler is the interface implemented by types that // can marshal themselves into valid JSON. type Marshaler interface { MarshalJSON() ([]byte, error) }  當你傳進去的物件有實作了這兩個 function 時，他會改用物件自己的方法 看看下面的範例他已經完全地掌握了 json.Marshal 的輸出啦\n// Box 是個箱子 type Box struct { Name string `json:\u0026quot;name\u0026quot;` Color string `json:\u0026quot;color\u0026quot;` } // UnmarshalJSON 實作箱子的 json.Unmarshaler func (b *Box) UnmarshalJSON(byteData []byte) (err error) { // 臨時變數，不直接用 Box 物件，會遞迴 type _box Box newBox := \u0026amp;struct{ *_box }{ _box: (*_box)(b), } newBox.Color = \u0026quot;會被蓋掉\u0026quot; return json.Unmarshal(byteData, newBox) } // MarshalJSON 實作箱子的 json.Marshaler func (b *Box) MarshalJSON() (byteData []byte, err error) { // 臨時變數，不直接用 Box 物件，會遞迴 type _box Box newBox := \u0026amp;struct{ *_box }{ _box: (*_box)(b), } newBox.Name = b.Name + \u0026quot;~~⭐️\u0026quot; return json.Marshal(newBox) } func main() { jsonStr := ` { \u0026quot;name\u0026quot;: \u0026quot;喵喵\u0026quot;, \u0026quot;color\u0026quot;: \u0026quot;blue\u0026quot; }` box := new(Box) _ = json.Unmarshal([]byte(jsonStr), box) fmt.Printf(\u0026quot;%+v\\n\u0026quot;, box) // \u0026amp;{Name:喵喵 Color:你只能是黑色} box.Color = \u0026quot;黃色的\u0026quot; byteJSON, _ := json.Marshal(box) fmt.Printf(\u0026quot;%s\\n\u0026quot;, string(byteJSON)) // {\u0026quot;name\u0026quot;:\u0026quot;喵喵~~⭐️\u0026quot;,\u0026quot;color\u0026quot;:\u0026quot;黃色的\u0026quot;} }  三、多層的方法 再來就是混合表演啦，要根據不同的格式回傳不同的 struct 類型\n例子是箱子裡面還可以再裝箱子，還可以裝各種不同的箱子～\npackage main import ( \u0026quot;encoding/json\u0026quot; \u0026quot;errors\u0026quot; \u0026quot;fmt\u0026quot; ) type iBox interface{} // Box 是個箱子 type Box struct { Type string `json:\u0026quot;type\u0026quot;` Name string `json:\u0026quot;name\u0026quot;` Color string `json:\u0026quot;color\u0026quot;` Box iBox `json:\u0026quot;box,omitempty\u0026quot;` } // UnmarshalJSON 實作箱子的 json.Unmarshaler func (b *Box) UnmarshalJSON(byteData []byte) (err error) { // 臨時變數，不要直接用 Box 物件，會遞迴 type _box Box newBox := \u0026amp;struct{ *_box }{ _box: (*_box)(b), } err = json.Unmarshal(byteData, \u0026amp;newBox) if err != nil { return } // 上面處理完了其他變數，再來依照 newBox 的 type 來\u0008包裝裡面的 box if newBox.Box != nil { switch newBox.Type { case \u0026quot;box\u0026quot;: innerBox := \u0026amp;struct { InnerBox Box `json:\u0026quot;box\u0026quot;` }{} err = json.Unmarshal(byteData, \u0026amp;innerBox) if err != nil { return } newBox.Box = innerBox.InnerBox case \u0026quot;xbox\u0026quot;: innerBox := \u0026amp;struct { InnerBox xBox `json:\u0026quot;box\u0026quot;` }{} err = json.Unmarshal(byteData, \u0026amp;innerBox) if err != nil { return } newBox.Box = innerBox.InnerBox } } return } // xBox 是特別的箱子 type xBox struct { Type string `json:\u0026quot;type\u0026quot;` Name string `json:\u0026quot;xName\u0026quot;` Foo string `json:\u0026quot;foo\u0026quot;` Box iBox `json:\u0026quot;box,omitempty\u0026quot;` } // UnmarshalJSON 實作 x箱子的 json.Unmarshaler func (b *xBox) UnmarshalJSON(byteData []byte) (err error) { type _box xBox newBox := \u0026amp;struct{ *_box }{ _box: (*_box)(b), } err = json.Unmarshal(byteData, \u0026amp;newBox) if err != nil { return } if newBox.Box != nil { switch newBox.Type { case \u0026quot;box\u0026quot;: innerBox := \u0026amp;struct { InnerBox Box `json:\u0026quot;box\u0026quot;` }{} err = json.Unmarshal(byteData, \u0026amp;innerBox) if err != nil { return } newBox.Box = innerBox.InnerBox case \u0026quot;xbox\u0026quot;: innerBox := \u0026amp;struct { InnerBox xBox `json:\u0026quot;box\u0026quot;` }{} err = json.Unmarshal(byteData, \u0026amp;innerBox) if err != nil { return } newBox.Box = innerBox.InnerBox } } return } func getInnerBox(boxType string, byteData []byte) (iBox, error) { switch boxType { case \u0026quot;box\u0026quot;: innerBox := \u0026amp;struct { InnerBox Box `json:\u0026quot;box\u0026quot;` }{} err := json.Unmarshal(byteData, \u0026amp;innerBox) if err != nil { return nil, err } return innerBox.InnerBox, nil case \u0026quot;xbox\u0026quot;: innerBox := \u0026amp;struct { InnerBox xBox `json:\u0026quot;box\u0026quot;` }{} err := json.Unmarshal(byteData, \u0026amp;innerBox) if err != nil { return nil, err } return innerBox.InnerBox, nil } return nil, errors.New(\u0026quot;unknown type of box\u0026quot;) } func main() { jsonStr := ` { \u0026quot;type\u0026quot;: \u0026quot;box\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;喵喵\u0026quot;, \u0026quot;color\u0026quot;: \u0026quot;藍色\u0026quot;, \u0026quot;box\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;xbox\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;裡面的\u0026quot;, \u0026quot;foo\u0026quot;: \u0026quot;bar\u0026quot;, \u0026quot;box\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;box\u0026quot;, \u0026quot;color\u0026quot;: \u0026quot;更裡面的\u0026quot;, \u0026quot;box\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;box\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;最裡面\u0026quot; } } } }` box := new(Box) _ = json.Unmarshal([]byte(jsonStr), box) // 然後你可以這樣! // layer 1 全部 fmt.Printf(\u0026quot;layer 1:\\n%#v\\n\\n\u0026quot;, box) // layer 2 \u0026quot;name=喵喵\u0026quot; fmt.Printf(\u0026quot;layer 2:\\n%#v\\n\\n\u0026quot;, box.Box.(Box)) // layer 3 \u0026quot;name=裡面的\u0026quot; fmt.Printf(\u0026quot;layer 3:\\n%#v\\n\\n\u0026quot;, box.Box.(Box).Box.(xBox)) // layer 4 \u0026quot;name=\u0026quot;更裡面的\u0026quot; fmt.Printf(\u0026quot;layer 4:\\n%#v\\n\\n\u0026quot;, box.Box.(Box).Box.(xBox).Box) // layer 5 \u0026quot;name=最裡面\u0026quot; 這層沒有 box，所以是 nil fmt.Printf(\u0026quot;layer 5:\\n%#v\\n\\n\u0026quot;, box.Box.(Box).Box.(xBox).Box.(Box).Box) }  也可以把重複的部份抽出來，不然豈不是每次新增新的 box 時都要改以前的 code？\n// UnmarshalJSON 實作 x箱子的 json.Unmarshaler func (b *xBox) UnmarshalJSON(byteData []byte) (err error) { type _box xBox newBox := \u0026amp;struct{ *_box }{ _box: (*_box)(b), } err = json.Unmarshal(byteData, \u0026amp;newBox) if err != nil { return } // 上面處理完了其他變數，再來依照 newBox 的 type 來\u0008包裝裡面的 box if newBox.Box != nil { newBox.Box, err = getInnerBox(newBox.Type, byteData) if err != nil { return } } return } func getInnerBox(boxType string, byteData []byte) (iBox, error) { switch boxType { case \u0026quot;box\u0026quot;: innerBox := \u0026amp;struct { InnerBox Box `json:\u0026quot;box\u0026quot;` }{} err := json.Unmarshal(byteData, \u0026amp;innerBox) if err != nil { return nil, err } return innerBox.InnerBox, nil case \u0026quot;xbox\u0026quot;: innerBox := \u0026amp;struct { InnerBox xBox `json:\u0026quot;box\u0026quot;` }{} err := json.Unmarshal(byteData, \u0026amp;innerBox) if err != nil { return nil, err } return innerBox.InnerBox, nil } return nil, errors.New(\u0026quot;unknown type of box\u0026quot;) }  結論 原本傻傻的不會用 Unmarshaler Marshaler，很難去做到多層的實作，現在會惹QQ\n參考資料 https://medium.com/@xfstart07/go-json-%E7%9A%84%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81-e689522a1f1f\nhttps://github.com/line/line-bot-sdk-go/blob/362880a2e613ce24eb32e1b72cd345370578b6df/linebot/flex_unmarshal.go#L23\n","id":23,"section":"posts","summary":"json 格式簡單易讀，經常出現在各種 API、設定檔裡，golang 也有內建處理的 package，寫扣的時候也會經常遇到他喔，來筆記一下！ 內文會分成","tags":["golang","json"],"title":"Golang 怎麼處理 JSON","uri":"https://blog.10oz.tw/20200228-golang-json-marshal/","year":"2020"},{"content":"步驟教學 一、開始之前 目標是用 hugo 協助我們使用 markdown 輕鬆製造靜態網頁，再把這個靜態網頁利用 Github Page 部署出去！\n所以我們需要:\n 一人份的 github 帳號 安裝 hugo 點我看教學 挑選喜歡的 hugo 模板 點我參觀  $ hugo version Hugo Static Site Generator v0.62.2/extended darwin/amd64 BuildDate: unknown  二、開跑囉 開啟一個新的 hugo 專案，這邊的 xiaoxiao 可以換成你喜歡的專案名字\n$ hugo new site xiaoxiao $ cd xiaoxiao  會看到目錄長這樣:\n├── archetypes │ └── default.md # 產生新文章時的模板 ├── config.toml # 最主要的設定檔案 ├── content # Markdown 的文章在這邊 ├── data ├── layouts ├── resources │ └── _gen ├── static └── themes # 套用的主題包們 └── hugo-theme-m10c  接著挑選一個漂亮的 hugo 模板來下載，我用人家教學示範的模板\n$ git clone https://github.com/vaga/hugo-theme-m10c.git themes/hugo-theme-m10c  再來，開啟文字編輯器修改 config.toml， 最主要是第六行的 theme 和第四行的 publishDir = \u0026quot;docs\u0026quot;，docs 是 GithubPage 規定的喔不能改\n我的改完長這樣:\nbaseURL = \u0026quot;https://xiaoxiaosn.github.io\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;XiaoXiao Notes\u0026quot; publishDir = \u0026quot;docs\u0026quot; theme = \u0026quot;hugo-theme-m10c\u0026quot; paginate = 10 [params] author = \u0026quot;Xiao Xiao\u0026quot; description = \u0026quot;XiaoXiao 的筆記書\u0026quot;  跑跑看，是不是能看到頁面啦? 服務會在 http://localhost:1313\n$ hugo server -D # -D 表示我們想看到草稿文章(draft)  看到有安捏就對了! 三、來寫文章r 這邊的 make-a-hugo-blog 可以換成你想要的文章名字，等等會被用在網址上喔\n$ hugo new make-a-hugo-blog  這個指令會幫你在 content 目錄下新增一個 make-a-hugo-blog.md 檔案， 接著我們寫點內容上去，像這樣: 要注意的是 draft: true 這行在正式上線的時候記得刪掉喔~\n--- title: \u0026quot;製造一個 hugo 部落格\u0026quot; date: 2020-01-24T23:02:16+08:00 tags: [\u0026quot;hugo\u0026quot;] --- ## 開始之前 目標是用 hugo 協助我們使用 markdown 輕鬆製造靜態網頁，再把這個靜態網頁利用 Github Page 部署出去！ 所以我們需要: 1. 一人份的 github 帳號 2. 安裝 hugo [點我看教學](https://gohugo.io/getting-started/installing#quick-install) 3. 挑選喜歡的 hugo 模板 [點我參觀](https://themes.gohugo.io/tags/blog/)  輸入 hugo 指令，讓他跑編譯囉\n$ hugo  四、來部署r 打開你的 github 按下 new 來新增一個 repo\n接下來會進到這個畫面，先不急著跟他操作 我們要先到 config.toml 修改域名 這邊的規則是 https://帳號.github.io/專案\n# 修改 config.toml 的這一行 baseURL = \u0026quot;https://xiaoxiaosn.github.io/XiaoXiaoBlog\u0026quot;  然後下指令重新產生一下\n$ hugo  回到專案，是時候該讓 git 加入了 第二行這邊記得換成你自己的 github 專案喔\n$ git init $ git remote add origin git@github.com:XiaoXiaoSN/XiaoXiaoBlog.git  $ git add --all $ git commit -m \u0026quot;init my hugo blog\u0026quot; $ git push origin master  在 add 的時候出現 warn 不擔心，他只是提醒你在這個 git 專案下還有包含了另一個 git 專案 (theme裡面那個) 更新上去後，我們回到 github，選擇 Setting 後往下拉找到 Github Page\n選那個 master branch /docs folder\n五、收割囉~~ 等待 10 秒，然後帶著一顆誠摯的新把連結給按下去 XD https://帳號.github.io/專案\n選修 - 使用自己的 domain 回到前面部署時候的頁面，Setting 往下滑到 GitHub Pages 填寫 Custom domain 的這個欄位\n這裡我已經有 domain，然後是交給 cloudflare 管理，因此接下來會以此介紹 開啟 cloudflare 選到 DNS 後，設定 CNAME 把你的網址導引到 githubPage 接下來到 Page Rules 新增一筆強制使用 https 的選項 這樣就設定好囉～ 記得要回到專案的 config.toml 設定新的 url 喔\nbaseURL = \u0026quot;https://blog.10oz.tw\u0026quot;  補充設定 md 換行格式 由於很多人從 hackmd 或是其他的平台轉過來 發現他們原來的 md 貼過來換行符號沒有被保留在 html 上，也就是兩行連起來啦\n[blackfriday] extensions = [\u0026quot;hardLineBreak\u0026quot;]   References hugo\n https://gohugo.io/documentation/ https://siddharam.com.tw/post/20190418/  github page\n https://gohugo.io/hosting-and-deployment/hosting-on-github/#deployment-of-project-pages-from-docs-folder-on-master-branch https://blog.cloudflare.com/secure-and-fast-github-pages-with-cloudflare/  ","id":24,"section":"posts","summary":"步驟教學 一、開始之前 目標是用 hugo 協助我們使用 markdown 輕鬆製造靜態網頁，再把這個靜態網頁利用 Github Page 部署出去！ 所以我們需要: 一人份的 github 帳號 安裝 hugo 點我看教學","tags":["hugo"],"title":"製造一個 hugo 部落格","uri":"https://blog.10oz.tw/20200124-make-a-hugo-blog/","year":"2020"},{"content":" ** 2019.08 更新** https://www.php.net/manual/en/mongodb.installation.homebrew.php mac php72 請使用 pecl install mongodb 安裝 mongodb driver 因為 mongodb, xdebug 從 homebrew 被移除了\n[time=Thu, Aug 15, 2019 7:59 PM]\n 問題描述 想在 Laravel 用 MongoDB\ncomposer require jenssegers/mongodb  錯誤：\nthe requested PHP extension mongodb is missing from your system.  =\u0026gt; 沒有裝 php 的擴展\n解決方案 先來個悲劇， homebrew 拿掉 php-mongodb 的擴展了QQ\n只好去裝人家的，我的 php 版本是 7.1 所以裝 php71-mongodb 忘記版本的話可以用 php --version 查看\nbrew tap kyslik/php brew install phpxx-mongodb {xx = 71,72}  裝完惹！ 但是當我輸入 php -i 檢查的時候 dyld: Library not loaded: /usr/local/opt/readline/lib/libreadline.7.dylib\n哎呀QQ 來去 Google 看看\nln -s /usr/local/opt/readline/lib/libreadline.8.0.dylib /usr/local/opt/readline/lib/libreadline.7.dylib  之後可以輸入來檢查有沒有成功\n» php -m | grep mongodb mongodb  link 我手上有的版本過去之後，一切順利呢！！\ncomposer require jenssegers/mongodb   後記 - 小踩雷   要是php -i | grep mongodb什麼都沒有的話可能是當初在安裝php的時候沒有安裝完全\n 移除php重裝一次 然後 brew link phpxx 你的 /usr/local/有可能會沒有sbin這個資料夾所以就mkdir sbin他 然後成功連結他應該就可以惹 ※小秘訣：你可以跑  brew doctor 叫醫生幫你診斷～     跑起來遇到\n  Symfony\\Component\\Debug\\Exception\\FatalThrowableError : Call to a member function prepare() on null  可以把原本 extend 的 Model 換成  \\Jenssegers\\Mongodb\\Eloquent\\Model\n","id":25,"section":"posts","summary":"** 2019.08 更新** https://www.php.net/manual/en/mongodb.installation.homebrew.php mac php72 請使用 pecl install mongodb 安裝 mongodb driver 因為 mongodb, xdebug 從 homebrew 被移除了 [time=Thu, Aug 15, 2019 7:59 PM] 問題描述 想在 Laravel 用 MongoDB composer require jenssegers/mongodb 錯誤： the requested PHP extension mongodb is missing from your system. =\u0026gt; 沒有裝 php 的擴展 解決","tags":["php","laravel","mongodb"],"title":"筆記 Install php MongoDB driver on MacOS","uri":"https://blog.10oz.tw/20190815-install-php-mongodb-driver-on-macos/","year":"2019"},{"content":" @elasticsearch version 6.8\n STRUCTURE 可以這樣想像\nRelational DB -\u0026gt; Databases -\u0026gt; Tables -\u0026gt; Rows -\u0026gt; Columns\nElasticsearch -\u0026gt; Indices -\u0026gt; Types -\u0026gt; Documents -\u0026gt; Fields\n不過啊，type 要被人家丟掉了（現在是限制只能有一個 type，等同於這層沒意義）\nIndices created in 6.x only allow a single-type per index.  6.x 後建議 type 使用 _doc，\n然後 8.x: Specifying types in requests is no longer supported.\n我發現我發現 看一眼 reindex 就很清楚他改了什麼了喔！\nPOST _reindex { \u0026quot;source\u0026quot;: { \u0026quot;index\u0026quot;: \u0026quot;twitter\u0026quot; }, \u0026quot;dest\u0026quot;: { \u0026quot;index\u0026quot;: \u0026quot;new_twitter\u0026quot; }, \u0026quot;script\u0026quot;: { \u0026quot;source\u0026quot;: \u0026quot;\u0026quot;\u0026quot; ctx._source.type = ctx._type; ctx._id = ctx._type + '-' + ctx._id; ctx._type = '_doc'; \u0026quot;\u0026quot;\u0026quot; } }  這是一個新增範例，依照 /Index/Type/ID 新增一筆 Document\nPUT /employee/_doc/1 { \u0026quot;first_name\u0026quot; : \u0026quot;John\u0026quot;, \u0026quot;last_name\u0026quot; : \u0026quot;Smith\u0026quot;, \u0026quot;age\u0026quot; : 25, \u0026quot;about\u0026quot; : \u0026quot;I love to go rock climbing\u0026quot;, \u0026quot;interests\u0026quot;: [\u0026quot;sports\u0026quot;, \u0026quot;music\u0026quot;] }  USAGE 列出所有 index\nGET /_cat/indices?v  所有在 index 中的 type\nGET /_mapping?pretty=true  Search - ES DSL Query DSL(Domain Specific Language)\n架構介紹 來自這邊\nGET /_search { \u0026quot;query\u0026quot;: { \u0026quot;bool\u0026quot;: { \u0026quot;must\u0026quot;: [ { \u0026quot;match\u0026quot;: { \u0026quot;title\u0026quot;: \u0026quot;Search\u0026quot; }}, { \u0026quot;match\u0026quot;: { \u0026quot;content\u0026quot;: \u0026quot;Elasticsearch\u0026quot; }} ], \u0026quot;filter\u0026quot;: [ { \u0026quot;term\u0026quot;: { \u0026quot;status\u0026quot;: \u0026quot;published\u0026quot; }}, { \u0026quot;range\u0026quot;: { \u0026quot;publish_date\u0026quot;: { \u0026quot;gte\u0026quot;: \u0026quot;2015-01-01\u0026quot; }}} ] } } }  在 bool 裡面， must match 表示檢索的評分項目\n而 filter 中的兩個 term 和 range 表示過濾條件，不會影響到評分\n由 index 來搜尋\nGET users/_search { \u0026quot;query\u0026quot;: { \u0026quot;match_all\u0026quot;: { } } }  多個 index 搜尋是這樣的 GET /kimchy,elasticsearch/_search?q=tag:wow  MatchAll GET /_search { \u0026quot;query\u0026quot;: { \u0026quot;match_all\u0026quot;: {} } }  match_none 是他的相反\nRollover Index 可參考 文件。當檔案大時，可以利用 rollover index 來分檔案，並且利用 alias 統一搜尋\nPUT /logs-000001 { \u0026quot;aliases\u0026quot;: { \u0026quot;logs_write\u0026quot;: {} } } # Add \u0026gt; 1000 documents to logs-000001 POST /logs_write/_rollover { \u0026quot;conditions\u0026quot;: { \u0026quot;max_age\u0026quot;: \u0026quot;7d\u0026quot;, \u0026quot;max_docs\u0026quot;: 1000, \u0026quot;max_size\u0026quot;: \u0026quot;5gb\u0026quot; } }  也可以使用日期來做\n# PUT /\u0026lt;logs-{now/d}-1\u0026gt; with URI encoding: PUT /%3Clogs-%7Bnow%2Fd%7D-1%3E { \u0026quot;aliases\u0026quot;: { \u0026quot;logs_write\u0026quot;: {} } }  Mapping Mapping 可以設定這個 Index 裡面的 Fields 的 type\nref\n 如果你是 7.x 記得看到 _doc 就給它拿掉\n PUT twitter {} PUT twitter/_mapping/_doc { \u0026quot;properties\u0026quot;: { \u0026quot;email\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;keyword\u0026quot; } } }  GET /twitter/_mapping/_doc  ILM (Index Lifecycle Management) rollover 的條件是當你 call API 的時候才會檢查，也就是說他不會自動生效 而 ILM 的功能就是讓 elasticsearch 排程幫你做 rollover\n 先開一個 policy  PUT _ilm/policy/mylogs_policy { \u0026quot;policy\u0026quot;: { \u0026quot;phases\u0026quot;: { \u0026quot;hot\u0026quot;: { \u0026quot;actions\u0026quot;: { \u0026quot;rollover\u0026quot;: { \u0026quot;max_docs\u0026quot;: \u0026quot;4\u0026quot;, \u0026quot;max_age\u0026quot;: \u0026quot;30d\u0026quot;, \u0026quot;max_size\u0026quot;: \u0026quot;5gb\u0026quot; } } } } } }  開一個 template 綁定這個 policy  PUT /_template/mylogs_template { \u0026quot;index_patterns\u0026quot;: [\u0026quot;mylogs-*\u0026quot;], \u0026quot;settings\u0026quot;: { \u0026quot;number_of_shards\u0026quot;: 1, \u0026quot;number_of_replicas\u0026quot;: 1, \u0026quot;index.lifecycle.name\u0026quot;: \u0026quot;mylogs_policy\u0026quot;, \u0026quot;index.lifecycle.rollover_alias\u0026quot;: \u0026quot;mylogs\u0026quot; } }  建立 alias  # PUT /\u0026lt;mylogs-000001\u0026gt; PUT %3Cmylogs-000001%3E { \u0026quot;aliases\u0026quot;:{ \u0026quot;mylogs\u0026quot;: { \u0026quot;is_write_index\u0026quot;:true } } }  當這個 alias 會被用於寫入時，要將 is_write_index 設定成 true，同時間 is_write_index=true 只會有一筆\n一直打資料進去 mylogs，他會依照上面的設定 rollover   可透過別名查詢所有 index\nPOST /prod_vpn_event/_refresh GET /prod_vpn_event/_search { \u0026quot;query\u0026quot;: { \u0026quot;match_all\u0026quot;: {} } }   REFERENCE https://es.xiaoleilu.com https://www.elastic.co/guide/en/elasticsearch/reference/6.8/query-dsl.html ILM https://elasticsearch.cn/article/6358\n","id":26,"section":"posts","summary":"@elasticsearch version 6.8 STRUCTURE 可以這樣想像 Relational DB -\u0026gt; Databases -\u0026gt; Tables -\u0026gt; Rows -\u0026gt; Columns Elasticsearch -\u0026gt; Indices -\u0026gt; Types -\u0026gt; Documents -\u0026gt; Fields 不過啊，type 要被人家丟掉了（現在是限制只能有一個 type，等同於這層沒意義） Indices","tags":["es","elasticsearch","ilm"],"title":"Learning Elasticsearch","uri":"https://blog.10oz.tw/20190814-learning-elasticsearch/","year":"2019"},{"content":" laravel version: 5.8 [time=Wed, Jul 3, 2019 1:27 PM]\n 開始之前 test 的設定檔在 ./phpunit.xml ，\n\u0026lt;!-- phpunit.xml --\u0026gt; \u0026lt;phpunit\u0026gt; \u0026lt;php\u0026gt; \u0026lt;!-- laravel 環境設定檔案使用 .emv.testing --\u0026gt; \u0026lt;server name=\u0026quot;APP_ENV\u0026quot; value=\u0026quot;testing\u0026quot;/\u0026gt; \u0026lt;!-- 測試環境的資料庫連線設定，我們將使用 sqlite --\u0026gt; \u0026lt;server name=\u0026quot;DB_CONNECTION\u0026quot; value=\u0026quot;sqlite_for_testing\u0026quot;/\u0026gt; \u0026lt;env name=\u0026quot;DB_DATABASE\u0026quot; value=\u0026quot;:memory:\u0026quot;/\u0026gt; \u0026lt;/php\u0026gt; \u0026lt;/phpunit\u0026gt;  php 也要加在 Config/dataset.php\n/* Config/dataset.php */ \u0026lt;?php 'connections' =\u0026gt; [ // ...other db connection configuration // 為了方便測試，使用 memory sqlite 做為我們的資料庫 'sqlite_for_testing' =\u0026gt; [ 'driver' =\u0026gt; 'sqlite', 'database' =\u0026gt; ':memory:', 'prefix' =\u0026gt; '', 'foreign_key_constraints' =\u0026gt; true, ], ]  確認好設定後，我們執行起來\n# -v 代表 --verbose 顯示更詳細的資訊 ./vendor/bin/phpunit -v --debug  寫個測試來跑跑 最近要重構一個 function，覺得裡面的邏輯有點複雜，決定先寫個測試再來開工\n這次的目標是 app/Http/Services/ScheduleService.php 裡面的 checkScheduleAvailable 這個 function\n所以我們先來準備測試檔案:\nphp artisan make:test Schedule/availableTest --unit  產生了一個 tests/Unit/Schedule/availableTest.php ，來看看裡面有什麼吧\n\u0026lt;?php // test 開頭的 function 會被測試 public function testExample() { // assertTrue 指定結果要是 true, // 因為 (true === true) ，所以我們將會通過測試 $this-\u0026gt;assertTrue(true); }  製造假資料 為了測試 function 能夠順利回傳，總要給點資料才能測吧?\n\u0026lt;?php class availableTest extends TestCase { // 資料庫每次用完要復原，才不會讓測試資料一直留在資料庫中 use RefreshDatabase; public function testQueryUnAvailable(): void { // inject some fake data into database factory(User::class)-\u0026gt;create(); factory(Project::class)-\u0026gt;create(); factory(Pole::class, 5)-\u0026gt;create(); $ad = factory(Ad::class)-\u0026gt;make([ 'ad_status_id' =\u0026gt; 4, // ad_status_id: 4 is depolyed 'ad_types_id' =\u0026gt; 1, // ad_types_id: 1 is slideshow ]); factory(Ad::class)-\u0026gt;create($ad-\u0026gt;toArray()); // 測試一波，資料是不是有好好的塞進資料庫了 $this-\u0026gt;assertCount(5, Pole::all()); $this-\u0026gt;assertDatabaseHas('ads', [ 'ad_status_id' =\u0026gt; 4, 'ad_types_id' =\u0026gt; 1, ]); } }  Ref https://blog.goodjack.tw/2018/07/laravel-phpunit.html https://gist.github.com/jaceju/c415c1b42daf4c589f2a https://laravel.com/docs/5.8/database-testing\n","id":27,"section":"posts","summary":"laravel version: 5.8 [time=Wed, Jul 3, 2019 1:27 PM] 開始之前 test 的設定檔在 ./phpunit.xml ， \u0026lt;!-- phpunit.xml --\u0026gt; \u0026lt;phpunit\u0026gt; \u0026lt;php\u0026gt; \u0026lt;!-- laravel 環境設定檔案使用 .emv.testing --\u0026gt; \u0026lt;server name=\u0026quot;APP_ENV\u0026quot; value=\u0026quot;testing\u0026quot;/\u0026gt; \u0026lt;!-- 測試環境的資料庫連線設定，我們將使用 sqlite --\u0026gt; \u0026lt;server name=\u0026quot;DB_CONNECTION\u0026quot; value=\u0026quot;sqlite_for_testing\u0026quot;/\u0026gt; \u0026lt;env name=\u0026quot;DB_DATABASE\u0026quot; value=\u0026quot;:memory:\u0026quot;/\u0026gt; \u0026lt;/php\u0026gt; \u0026lt;/phpunit\u0026gt;","tags":["php","laravel","test"],"title":"筆記 laravel test - 我們也來寫測試","uri":"https://blog.10oz.tw/20190703-laravel-testing/","year":"2019"},{"content":" Laravel 5.8\n $kernel = $app-\u0026gt;make(Illuminate\\Contracts\\Console\\Kernel::class); $output = new Symfony\\Component\\Console\\Output\\ConsoleOutput; $output-\u0026gt;getFormatter() -\u0026gt;setStyle('error', new \\Symfony\\Component\\Console\\Formatter\\OutputFormatterStyle('yellow')); $status = $kernel-\u0026gt;handle( $input = new Symfony\\Component\\Console\\Input\\ArgvInput, $output );  修改的話在 line:37 可以帶三種參數\npublic function __construct( string $foreground = null, string $background = null, array $options = []){ /****/ }  三種參數可以參考\nprivate static $availableForegroundColors = [ 'black' =\u0026gt; ['set' =\u0026gt; 30, 'unset' =\u0026gt; 39], 'red' =\u0026gt; ['set' =\u0026gt; 31, 'unset' =\u0026gt; 39], 'green' =\u0026gt; ['set' =\u0026gt; 32, 'unset' =\u0026gt; 39], 'yellow' =\u0026gt; ['set' =\u0026gt; 33, 'unset' =\u0026gt; 39], 'blue' =\u0026gt; ['set' =\u0026gt; 34, 'unset' =\u0026gt; 39], 'magenta' =\u0026gt; ['set' =\u0026gt; 35, 'unset' =\u0026gt; 39], 'cyan' =\u0026gt; ['set' =\u0026gt; 36, 'unset' =\u0026gt; 39], 'white' =\u0026gt; ['set' =\u0026gt; 37, 'unset' =\u0026gt; 39], 'default' =\u0026gt; ['set' =\u0026gt; 39, 'unset' =\u0026gt; 39], ]; private static $availableBackgroundColors = [ 'black' =\u0026gt; ['set' =\u0026gt; 40, 'unset' =\u0026gt; 49], 'red' =\u0026gt; ['set' =\u0026gt; 41, 'unset' =\u0026gt; 49], 'green' =\u0026gt; ['set' =\u0026gt; 42, 'unset' =\u0026gt; 49], 'yellow' =\u0026gt; ['set' =\u0026gt; 43, 'unset' =\u0026gt; 49], 'blue' =\u0026gt; ['set' =\u0026gt; 44, 'unset' =\u0026gt; 49], 'magenta' =\u0026gt; ['set' =\u0026gt; 45, 'unset' =\u0026gt; 49], 'cyan' =\u0026gt; ['set' =\u0026gt; 46, 'unset' =\u0026gt; 49], 'white' =\u0026gt; ['set' =\u0026gt; 47, 'unset' =\u0026gt; 49], 'default' =\u0026gt; ['set' =\u0026gt; 49, 'unset' =\u0026gt; 49], ]; private static $availableOptions = [ 'bold' =\u0026gt; ['set' =\u0026gt; 1, 'unset' =\u0026gt; 22], 'underscore' =\u0026gt; ['set' =\u0026gt; 4, 'unset' =\u0026gt; 24], 'blink' =\u0026gt; ['set' =\u0026gt; 5, 'unset' =\u0026gt; 25], 'reverse' =\u0026gt; ['set' =\u0026gt; 7, 'unset' =\u0026gt; 27], 'conceal' =\u0026gt; ['set' =\u0026gt; 8, 'unset' =\u0026gt; 28], ];  ","id":28,"section":"posts","summary":"Laravel 5.8 $kernel = $app-\u0026gt;make(Illuminate\\Contracts\\Console\\Kernel::class); $output = new Symfony\\Component\\Console\\Output\\ConsoleOutput; $output-\u0026gt;getFormatter() -\u0026gt;setStyle('error', new \\Symfony\\Component\\Console\\Formatter\\OutputFormatterStyle('yellow')); $status = $kernel-\u0026gt;handle( $input = new Symfony\\Component\\Console\\Input\\ArgvInput, $output ); 修改的話在 line:37 可以帶三種參數 public function __construct( string $foreground = null, string $background = null, array $options = []){ /****/ } 三種參數可以參考 private static $availableForegroundColors = [ 'black' =\u0026gt; ['set' =\u0026gt; 30,","tags":["php","laravel","artisan"],"title":"筆記 artisan 的大紅色好刺眼啊啊啊啊","uri":"https://blog.10oz.tw/20190523-laravel-artisan-change-color-style/","year":"2019"},{"content":" 從 golang 1.13 release(2019/09/03) 後，gomodule 變成預設，大家都用官方的 gomodule 了喔 在這之前的版本使用環境變數 GOMODULE111=true 來做管理\n 安裝 golang (on Mac) 1. 第一步當然是拿到 golnag 囉 brew install go  2. 環境設定 試著在 terminal 輸入 go env，能夠拿到 golang 用到的環境變數 特別注意一下幾個環境變數\n GOROOT: 是你 golang 執行環境住的地方 GOPATH: 是你的 golang 程式 和 用到的套件們所住的地方 GOBIN: 因為 golang 是編譯式的語言，他可以把相依套件事先build 好，製作成 .a 的二進位檔，存在 GOBIN 裡面  # create GOPATH dir mkdir $HOME/gocode  永久設定~~ 如果你的 shell 是 bash 的話 (預設) 開啟編輯器修改 $HOME/.bashrc 檔案，bash 在登入後會做上面的事情\n# edit $HOME/.bashrc vim $HOME/.bashrc  按下 G 到最底部後 i 進入編輯模式，把環境變數設定貼上去\nexport GOPATH=$HOME/gocode export GOBIN=$GOPATH/bin export PATH=$PATH:$GOBIN  按下esc退出編輯模式，輸入:wq存檔並離開\nor you are using fish vim ~/.config/fish/config.fish\n# GOLANG configurations set -x GOPATH $HOME/gocode set -x GOBIN $GOPATH/bin set -x GOROOT /usr/local/opt/go/libexec set PATH $GOPATH/bin $GOROOT/bin $PATH  重新再開一個小黑窗跑一下新的設定， 再一次 go env 看看幾個參數有沒有不同吧\n3. 下載專案 在下載前，有些事情是我們要知道的 Golang 的資料夾下有 src pkg bin 三個目錄\n src: 當你找相依套件時，會來拜訪這裡 pkg: 編譯好的 go 檔案(*.a)，使用相依套件時，可以直接取用 bin: 裡面是編譯好的二進位檔案（golang工具）們  先設定 ssh 下載我們的 repo，而不是 https\ngit config --global url.\u0026quot;git+ssh://git@gitlab.tenoz.tw/\u0026quot;.insteadOf \u0026quot;https://repo.tenoz.tw/\u0026quot; go get repo.tenoz.tw/leotek/pelipper  趕快來確認一下，是不是成功下載回來了呢？\ncd $GOPATH/src/repo.tenoz.tw/leotek/pelipper  4. 套件管理工具 go modules 推薦用這個\n先來看看 go modules 介紹) 吧\ngo vendor 前置任務：下載 govendor\ngo get -u github.com/kardianos/govendor  好，回來看一下\npelipper 這個專案就是用 govendor 來對他的套件做管理\n看一下 vendor/vendor.json 裡面寫了他使用的套件和版本\n一個指令下載相依套件\ngovendor sync  跑跑看~~\ngo build ./pelipper  雖然跑起來了， 不過他可能會跟你說他需要設定檔喔\n  附錄、還有其他管理工具 這裡有詳細資訊\ndep 官方推薦的管理包，不過有要被人家取代掉的趨勢\nGo Modules 94J個，窩看好ni啦 \u0026raquo; 介紹\n 參考資料 https://github.com/golang/go/wiki/PackageManagementTools https://ieevee.com/tech/2017/07/10/go-import.html\n","id":29,"section":"posts","summary":"從 golang 1.13 release(2019/09/03) 後，gomodule 變成預設，大家都用官方的 gomodule 了喔 在這之前的版本使用環境變數 GOMODULE111=true 來做管理 安裝 golang (on Mac) 1. 第一步當然是拿到 golnag 囉 brew install go 2. 環境設","tags":["golang"],"title":"筆記 安裝 Golang 與他們的套件管理工具","uri":"https://blog.10oz.tw/20190501-golang-getting-start-and-package-manager/","year":"2019"},{"content":"簡介 Golang 官方在 1.11 版推出的相依套件管理工具，還是在測試階段(會在1.13正式登場) 他在 2018/3/20 提交，並於 2018/5/21 被接受 想使用他的話，要開個開關： 環境變數 GO111MODULE 控制行為：\n off: go command 不使用 modules 功能，而是沿用舊有的 GOPATH 模式 on: 強制使用 modules 功能，只根據 go.mod 下載 dependency 而完全忽略 GOPATH 以及 vendor 目錄 auto: Golang 1.11 預設值，go command 根據當前工作目錄狀態決定是否啟用 modules 功能，滿足任一條件時才啟動此功能:  當前目錄位於 GOPATH/src 之外並且包含 go.mod 文件 當前目錄位於包含 go.mod 文件的目錄下    因此，我們的第一步就是開啟他\nexport GO111MODULE=on  來吧，新專案 mkdir goModTest cd goModTest  main.go // at goModTest/main.go package main import ( \u0026quot;net/http\u0026quot; \u0026quot;github.com/gin-gonic/gin\u0026quot; ) func main() { router := gin.Default() router.GET(\u0026quot;/health\u0026quot;, GetHealthHandler) s := \u0026amp;http.Server{ Addr: \u0026quot;:8000\u0026quot;, Handler: router, } s.ListenAndServe() } // GetHealthHandler - GET /health to expose service health func GetHealthHandler(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \u0026quot;code\u0026quot;: 0, \u0026quot;message\u0026quot;: \u0026quot;Service is alive!\u0026quot;, }) }  我們在 main.go 裡面用了 gin 這個 web framework\ngo mod init # 產生 go.mod go build # 編譯時會去下載缺少的相依套件  執行完後發現 go.mod 中多了幾個相依套件 還多了一個 go.sum， 他就像是其他語言的 .lock 一樣，是用來記錄安裝的版本\ntidy 自動幫你檢查你的程式碼中使用到的外部引用， 幫你加入你需要的也幫你移除你用不到的\ngo mod tidy  Vendor 預設的情況下，go mod 幫你把相依套件下載到 $GOPATH 不過你希望有放在專案目錄下的話\u0026hellip;\ngo mod tidy # 先做個整理，才不會多下載 go mod vendor  import local package 可以直接 import 專案下的模組，go.mod 知道你目前的位置在 goModTest 也就是寫在 go.mod 的第一行 module goModTest\n// 程式裡面這樣引用自己專案的package import dataapi \u0026quot;goModTest/pkg/myapi\u0026quot;   Reference 官方連結 https://github.com/golang/go/wiki/Modules 你看人家 Drone 也用了 https://github.com/drone/drone https://www.lightblue.asia/golang-1-11-new-festures-modules https://www.lightblue.asia/go-modules-with-insecure-git/\n","id":30,"section":"posts","summary":"簡介 Golang 官方在 1.11 版推出的相依套件管理工具，還是在測試階段(會在1.13正式登場) 他在 2018/3/20 提交，並於 2018/5/21 被接受 想使用他的話，要開個開關： 環境變數 GO111MODULE 控","tags":["golang","gomod"],"title":"筆記 我是個 go module 的菜鳥","uri":"https://blog.10oz.tw/20190501-a-new-in-go-module/","year":"2019"},{"content":" laravel version: 5.8\n 一、安裝篇 裝這個，跟著他的步驟做 https://github.com/robsontenorio/laravel-keycloak-guard\n二、使用篇 我們假設 Keycloak Server 有大大幫你開好了 (沒有請點我)\n取得 Keycloak 金鑰 https://auth.leotekiot.com 預設帳號: admin 預設密碼: Pa55w0rd\n登入後，依序操作得到金鑰 Realm Setting \u0026gt; Keys \u0026gt; RS256 Public key 放到 laravel 的 .env 設定中\nKEYCLOAK_REALM_PUBLIC_KEY=你的公開金鑰  登入 Keycloak Clients \u0026gt; {{ 選個Client }} \u0026gt; Credentials Secret 那邊就是我們的 Client Secret 了 User \u0026gt; View all users \u0026gt; {{ 選個User }} 或是你要新創一個也可以， 總之要記得你的帳號密碼喔\n移駕到 Postman 來嘗試登入 用這個 API 取得 token， auth_realm 填上現在使用的 Realm 預設是 Master\n/auth/realms/{{auth_realm}}/protocol/openid-connect/token  需要的參數前面有介紹過了，按照圖片填滿它吧！\n送出就有 AccessToken 了 應用他!! 複製剛才的 access_token 貼到那個需要登入的 API 裡面 Authorization \u0026gt; Type: Bearer Token \u0026gt; 成功登入～\n三、檢查權限篇 // import Auth use Illuminate\\Support\\Facades\\Auth; // 解析 JWT 並取得 token $tokenString = Auth::token(); return [ 'token' =\u0026gt; json_decode($tokenString) ]; // 從 token 來檢查權限(角色) $Role = 'admin'; $isAdmin = Auth::hasRole($CLIENT, $Role);  ","id":31,"section":"posts","summary":"laravel version: 5.8 一、安裝篇 裝這個，跟著他的步驟做 https://github.com/robsontenorio/laravel-keycloak-guard 二、使用篇 我們假設 Keycloak Server 有大大幫你開好了 (沒有請點我) 取得 Keycloak 金鑰 https://auth.leotekiot.com 預設帳號: admin 預設密碼: Pa55w0rd 登入後，依序","tags":["php","laravel","keycloak","oauth"],"title":"筆記 Laravel with Keycloak","uri":"https://blog.10oz.tw/20190424-laravel-with-keycloak/","year":"2019"},{"content":" 版本 Larael 5.7\n 範例模型 accounts\nCREATE TABLE `accounts` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `website_id` int(10) unsigned NOT NULL, `account` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `password` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `created_at` timestamp NULL DEFAULT NULL, `updated_at` timestamp NULL DEFAULT NULL, `deleted_at` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`) );  websites\nCREATE TABLE `websites` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `created_at` timestamp NULL DEFAULT NULL, `updated_at` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`) )  accounts table 底下有個 cloumn website_id 用來關聯 websites 這張表。\n正片開始 - Model Account 是一個 Model，跟 websites 屬於多對一的關係 一個 website 底下可以有很多 account\n方案一、加入參數 $with 在 Account.php 中\u0026hellip;\n// Account.php Account Model // will call getWebsiteAttribute and append to the model object protected $with = ['website']; public function website() { return $this-\u0026gt;belongsTo('App\\Website'); // 等於 $this-\u0026gt;belongsTo('App\\Website', 'website_id', 'id'); } public function getWebsiteAttribute() { return $this-\u0026gt;website()-\u0026gt;first(); }  他會自動幫你找到 $with 內的 relation\n輸出看起來像這樣，多了 website\n{ \u0026quot;id\u0026quot;: 1, \u0026quot;website_id\u0026quot;: 1, \u0026quot;account\u0026quot;: \u0026quot;ditto\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;niguai.tenoz.1006\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;meow\u0026quot;, \u0026quot;created_at\u0026quot;: \u0026quot;2019-01-28 06:58:44\u0026quot;, \u0026quot;updated_at\u0026quot;: \u0026quot;2019-01-28 06:58:44\u0026quot;, \u0026quot;website\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;meo.tw\u0026quot;, \u0026quot;created_at\u0026quot;: null, \u0026quot;updated_at\u0026quot;: null } }  方案二、 加入參數 $appends 只是把 $with 換成 $appends，可以達到一樣的效果\n// Account.php Account Model // will call getWebsiteAttribute and append to the model object protected $appends = ['website']; public function website() { return $this-\u0026gt;belongsTo('App\\Website'); } public function getWebsiteAttribute() { return $this-\u0026gt;website()-\u0026gt;first(); }  不過為什麼要重複做這樣的功能呢? 我認為 appends 跟 $with 的使用時機不同！ $with 更用在 關聯另外的資料表 時 $appends 則是可以用於加入其他資訊，像是:\n// Account.php Account Model protected $appends = ['uniqName']; public function getUniqNameAttribute() { return \u0026quot;{$this-\u0026gt;name}#{$this-\u0026gt;id}\u0026quot;; }  輸出看起來像這樣，多了 uniqName\n{ \u0026quot;id\u0026quot;: 1, \u0026quot;website_id\u0026quot;: 1, \u0026quot;account\u0026quot;: \u0026quot;ditto\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;niguai.tenoz.1006\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;meow\u0026quot;, \u0026quot;created_at\u0026quot;: \u0026quot;2019-01-28 06:58:44\u0026quot;, \u0026quot;updated_at\u0026quot;: \u0026quot;2019-01-28 06:58:44\u0026quot;, \u0026quot;uniqName\u0026quot;: \u0026quot;meow#1\u0026quot;, \u0026quot;website\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;meo.tw\u0026quot;, \u0026quot;created_at\u0026quot;: null, \u0026quot;updated_at\u0026quot;: null } }  :::info 小Hint: belongsTo 這個 function 會幫你猜你 relate 的 key column name， 他用的是你呼叫他的那個 function name\n因此， function website() 中的 belongsTo 可以省略掉後面兩個參數 :::\n","id":32,"section":"posts","summary":"版本 Larael 5.7 範例模型 accounts CREATE TABLE `accounts` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `website_id` int(10) unsigned NOT NULL, `account` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `password` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `created_at` timestamp NULL DEFAULT NULL, `updated_at` timestamp NULL DEFAULT NULL, `deleted_at` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`) ); websites CREATE TABLE `websites` ( `id` int(10) unsigned NOT","tags":["php","laravel","eloquent","orm"],"title":"筆記 Laravel Eloquent Model 的 relation","uri":"https://blog.10oz.tw/20190416-relation-of-laravel-eloquent-model/","year":"2019"},{"content":"使用 JWT 版本 (2018/09 更新)  前面幾個步驟同官方安裝教學\n 步驟說明 1. composer 載回來 composer require laravel/passport\n2. 開資料表 php artisan migrate 然後你會多 5 張表 (主要使用到 oauth_access_token)\n3.創造 key php artisan passport:install\n他會幫你的 OAuth Server 準備一對 Key (storage/oauth-private.key, storage/outhpublic.key)\n同時也準備 2 個 Client Key 在 oauth_clients 資料表內\nPersonal access client created successfully. Client ID: 1 Client Secret: ETOhMRq7faRSnb1jN2F168jlbYFcf25MOHj0cOxt Password grant client created successfully. Client ID: 2 Client Secret: fibc50RiIjAiYSLR7xceQyoxQE3oGWtIXpCLj9Co  4. 附加 passport 至 auth 系統  在 app\\User.php 新增 Laravel\\Passport\\HasApiTokens line:5,11  \u0026lt;?php namespace App; use Laravel\\Passport\\HasApiTokens; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use HasApiTokens, Notifiable; // ...   在 app/Providers/AuthServiceProvider.php 新增 passport 的 route (我們 jwt 版本可以不用) line:29  \u0026lt;?php namespace App\\Providers; use Laravel\\Passport\\Passport; use Illuminate\\Support\\Facades\\Gate; use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider; class AuthServiceProvider extends ServiceProvider { /** * The policy mappings for the application. * * @var array */ protected $policies = [ 'App\\Model' =\u0026gt; 'App\\Policies\\ModelPolicy', ]; /** * Register any authentication / authorization services. * * @return void */ public function boot() { $this-\u0026gt;registerPolicies(); Passport::routes(); // set when access tokens expire Passport::tokensExpireIn(now()-\u0026gt;addDays(15)); } }   在 config/auth.php\n修改 guard 使用 passport  'guards' =\u0026gt; [ 'web' =\u0026gt; [ 'driver' =\u0026gt; 'session', 'provider' =\u0026gt; 'users', ], 'api' =\u0026gt; [ 'driver' =\u0026gt; 'passport', 'provider' =\u0026gt; 'users', ], ],   修改 app/Http/Kernel.php\n加進 web middleware 中 (此步驟 JWT 才需要)  'web' =\u0026gt; [ // Other middleware... \\Laravel\\Passport\\Http\\Middleware\\CreateFreshApiToken::class, ],  5. 修改登入步驟 當我們登入成功的時候，回傳加密過的 jwt\n在 app/Http/Controllers/Auth/LoginController.php override 掉 authenticated function\n當登入成功的時候會進入這個function\ncreateToken 第一個參數是 token的名稱 第二個是權限領域(Scopes)，建立後可以在oauth_xxx 資料表中確認\n/** * The user has been authenticated. * Do not use the origin response of success login with 302, create access token * and return json format * * @param Request $request * @param User $user * @return \\Illuminate\\Http\\JsonResponse|\\Symfony\\Component\\HttpFoundation\\Response * @throws \\Illuminate\\Validation\\ValidationException */ protected function authenticated(Request $request, $user) { if (!is_null($user)) { // create persionalAccessToken for authrizate API $token = $user-\u0026gt;createToken('access_token', ['guard', 'employee'])-\u0026gt;accessToken ?: ''; return response()-\u0026gt;json([ 'access_token' =\u0026gt; $token ], 200); } // throw error return $this-\u0026gt;sendFailedLoginResponse($request); }  // 加入 scope middleware\n// 在 app/Http/Kernel.php 裡面的 $routeMiddleware\nscopes 是你指定的 scope 們都要通過 (AND)\nscope 則是你指定的 scope 們其中之一通過 (OR)\n可以挑需要用的(我是兩種都加進去了啦)\n'scopes' =\u0026gt; \\Laravel\\Passport\\Http\\Middleware\\CheckScopes::class, 'scope' =\u0026gt; \\Laravel\\Passport\\Http\\Middleware\\CheckForAnyScope::class,   回到 app/Providers/AuthServiceProvider.php 我們可以在這裡設定 scpoe 們 line:35  \u0026lt;?php namespace App\\Providers; use Laravel\\Passport\\Passport; use Illuminate\\Support\\Facades\\Gate; use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider; class AuthServiceProvider extends ServiceProvider { /** * The policy mappings for the application. * * @var array */ protected $policies = [ 'App\\Model' =\u0026gt; 'App\\Policies\\ModelPolicy', ]; /** * Register any authentication / authorization services. * * @return void */ public function boot() { $this-\u0026gt;registerPolicies(); // set when access tokens expire Passport::tokensExpireIn(now()-\u0026gt;addDays(15)); // set when refresh tokens expire Passport::refreshTokensExpireIn(now()-\u0026gt;addDays(30)); Passport::tokensCan([ 'admin' =\u0026gt; 'system admin', 'guard' =\u0026gt; 'a good guy', 'employee' =\u0026gt; 'just a poor engineer' ]); } }  6. 裝備上去 在 routes/api.php 加上 middleware auth 並指定 guard 是 api 這樣有加上 middleware 的 API 們， 沒有 token 就進不去囉！\nRoute::apiResource('report', 'API\\ReportController') -\u0026gt;middleware('auth:api')-\u0026gt;middleware('scope:employee,guard'); Route::post('/report/multi_assign', 'API\\ReportController@assignReports') -\u0026gt;middleware('auth:api')-\u0026gt;middleware('scope:guard');  7. 前端接收 在這裡我將token存在local storage裡面\n為了接收內容，所以將 make:auth產生的模板修改成 vue component 了\n範例使用 ajax 做登入\naxios.post('/login', { 'email': this.email, 'password': this.password }) .then(res =\u0026gt; { window.localStorage.setItem('accessToken', res.data.access_token) window.location.href = this.redirect_to }) .catch(err =\u0026gt; { console.error('login failed') // 處理回傳的錯誤訊息 })  在 resources/assets/js/bootstrap.js\n為了不用每一次送 API 請求都要手動加上 token， 我們修改 axios 的預設\n/** * We will use laravel/passport JWT to verify API permission. * Once user success to login, get a access token. The access token will be * stored in the Local Storage of browser. */ let accessToken = JSON.parse(window.localStorage.getItem('accessToken')|| null); if (accessToken) { window.axios.defaults.headers.common['Authorization'] = accessToken; }   補充\n可以在 app/Exceptions/Handler.php 做 error handle\n在這裡把全部的 api error 都回傳 401 未驗證， 不良示範XDD  /** * Convert an authentication exception into an unauthenticated response. * * @param \\Illuminate\\Http\\Request $request * @param \\Illuminate\\Auth\\AuthenticationException $exception * @return \\Illuminate\\Http\\Response */ protected function unauthenticated($request, AuthenticationException $exception) { if ($request-\u0026gt;expectsJson()) { return response()-\u0026gt;json(['error' =\u0026gt; 'Unauthenticated.'], 401); } $guard = array_get($exception-\u0026gt;guards(), 0); switch ($guard) { case 'web': $login = 'login'; break; case 'api': return response()-\u0026gt;json(['error' =\u0026gt; 'API Unauthenticated.'], 401); break; } return redirect()-\u0026gt;guest(route($login)); }  參考 Laravel 官方 Laravel Passport JWT Authentication\n OAuth2 什麼是 OAuth? 例如說你從你的服務要跟 google 拿取使用者的資訊\n   - -     Resourse Owner 使用者   Client 你的服務   Authorization Server 授權者，服務跟這邊拿token 如: google   Resource Server 服務會跟這裡拿資料    開始安裝 - 實戰時間  前幾個步驟同官方教學\n 1. composer 載回來 composer require laravel/passport\n2. 開表 php artisan migrate\n然後你會多 5 張表 (主要使用到 oauth_access_token)\n$ php artisan migrate Migrating: 2016_06_01_000001_create_oauth_auth_codes_table Migrated: 2016_06_01_000001_create_oauth_auth_codes_table Migrating: 2016_06_01_000002_create_oauth_access_tokens_table Migrated: 2016_06_01_000002_create_oauth_access_tokens_table Migrating: 2016_06_01_000003_create_oauth_refresh_tokens_table Migrated: 2016_06_01_000003_create_oauth_refresh_tokens_table Migrating: 2016_06_01_000004_create_oauth_clients_table Migrated: 2016_06_01_000004_create_oauth_clients_table Migrating: 2016_06_01_000005_create_oauth_personal_access_clients_table Migrated: 2016_06_01_000005_create_oauth_personal_access_clients_table  3. 創造 key php artisan passport:install\n他會幫你的 OAuth Server 準備一對 Key (storage/oauth-private.key, storage/outhpublic.key)\n同時也準備一組 Client Key 在 oauth_clients 資料表內\n$ php artisan passport:install Encryption keys generated successfully. Personal access client created successfully. Client ID: 1 Client secret: VJZEYfTpsHBkNCv9ULUyHvGBbJvYiD1ZVP86cbYu Password grant client created successfully. Client ID: 2 Client secret: l4kh71C2DpdUsNmJFipi0hiDnhdgj6VfF5lGGDam  4. 附加 passport 至 auth 系統  在 app\\User.php 新增一個 trait Laravel\\Passport\\HasApiTokens line:5,11  \u0026lt;?php namespace App; use Laravel\\Passport\\HasApiTokens; use Illuminate\\Notifications\\Notifiable; use Illuminate\\Foundation\\Auth\\User as Authenticatable; class User extends Authenticatable { use HasApiTokens, Notifiable; // other code...   在 app/Providers/AuthServiceProvider.php 新增 passport 的 route line:5 import passport line:29 add passport routes  \u0026lt;?php namespace App\\Providers; use Laravel\\Passport\\Passport; use Illuminate\\Support\\Facades\\Gate; use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider; class AuthServiceProvider extends ServiceProvider { /** * The policy mappings for the application. * * @var array */ protected $policies = [ 'App\\Model' =\u0026gt; 'App\\Policies\\ModelPolicy', ]; /** * Register any authentication / authorization services. * * @return void */ public function boot() { $this-\u0026gt;registerPolicies(); Passport::routes(); // set when access tokens expire Passport::tokensExpireIn(now()-\u0026gt;addDays(15)); } }   在 config/auth.php\n修改 guard 使用 passport  'guards' =\u0026gt; [ 'web' =\u0026gt; [ 'driver' =\u0026gt; 'session', 'provider' =\u0026gt; 'users', ], 'api' =\u0026gt; [ 'driver' =\u0026gt; 'passport', 'provider' =\u0026gt; 'users', ], ],  ","id":33,"section":"posts","summary":"使用 JWT 版本 (2018/09 更新) 前面幾個步驟同官方安裝教學 步驟說明 1. composer 載回來 composer require laravel/passport 2. 開資料表 php artisan migrate 然後你會多 5 張表 (主要使用到 oauth_access_token) 3.創造 key php artisan passport:install 他會幫你的","tags":["php","laravel","passport","jwt"],"title":"筆記 Laravel API 權限 (Passport)","uri":"https://blog.10oz.tw/20190217-laravel-api-permission-by-passport/","year":"2019"},{"content":"新手入門 結構介紹 我們現在在 laravel v5.7\n一起來看一下 laravel 專案的結構吧\napp 大部份的網頁後端主要程式碼 也就是說他很重要\n  (Model)放在外面的大寫開頭們～\n例如說 User.php 就是， 他們是 Model，定義了資料庫的物件模式\n  Http/\n Controllers/\ncontroller可以作為路由進來後的流程控制器，可以想像它負責告訴大家要做什麼 Middleware/\nmiddleware叫做中間層，用來包著你的程式內容，request 進出都會經過    bootstrap 程式啟動第一個執行的套件\nconfig 所有應用的設定檔們\ndatabase 顧名思義：資料庫～\n migrations/\n紀錄了資料庫的心路歷程\n其中定義了up跟down，模擬建立資料還有需要rollback回去時的動作 fatories/\n定義了一些資料的模式，可以使用seeder批量製造 seeds/\n他是一顆會長出資料的種子，當你需要產生測試用的資料的時候很常遇到他  public 對外公開給使用者看得到的資源\n Ex: 圖片、webpack包裝過的檔案  resources 本地資源\n  Ex: js的原始碼、CSS\u0026hellip;\n  /assets\n /js/components\n裡面寫了好多 vue component 們，他們是前端主力!    /views\n這邊放了 blade ，他是 laravel選用的模板引擎，幫你更智慧的寫你的html\n  routes  api.php 裡面註冊API web.php 裡面註冊網頁  他們最大的差別就是套用了不同的middleware\nstorage 網頁被儲存的資源\n Ex: log日誌檔案(紀錄檔)、檔案快取  tests 測試單元、整合測試\n大家都說用TDD比較快ㄛ\nvender 放別人code的地方\n拿別人的code來用\nlaradock 它幫助我們使用docker來建制服務\n laradock/.env 存放 laradock的設定參數  其他檔案  .env 在這個網頁會用到的參數，像是資料庫的密碼 artisan 放了些 laravel 的工作指令 composer.json composer 用在 php 的套件管理 當你需要幫你的 php 程式裝點別人的套件的時候，你會進來這邊看看 package.json javascript 的套件版本管理，還有 npm 指令喔 webpack.min.js webpack 會幫你打包前端的資源們  簡單操作 (by Xiao \u0026amp; Andrew \u0026amp; Dagg) 註冊路由 寫在 routes/web.php\n這邊可以試著用你的路由連上預設的welcome首頁了\n 你要在postman測試的話 要關掉csrf防禦 app/Http/Middleware/VerifyCsrfToken.php\n migrate - 開個資料表 php artisan make:migration crete_todoList_table  檔案會在 ./database/migration/ 檔名範例: 2018_01_22_170244_crete_todoList_table\ncolumn 建立說明 https://laravel.com/docs/5.5/migrations#creating-columns\n寫個Controller php artisan make:controller TodoListController  在 ./app/Http/Controller/ 會長出來\nresource  如果你加上 \u0026ndash;resource 的話,它會長出預設的幾個功能框框 而你可以在route裡面 Route::resource() 來管理他們 https://laravel.com/docs/5.5/controllers#resource-controllers\n 不得已用简体中文输入法的补充： 关于controller: 中层的class，管理http之间的行為（ ex: get and post method ） 另一种则是管理资源的class,管理对于资源的事件（ex: 图片的新增、修改、删除）, 称為resource controller 每一个controller都可以注册一个路由方便管理 如果想要resourcecontroller继承特定model特性的话, 可以在指令后方加上 --model=[model name]  所以我們的結論:\nAPI Controller + Model 的產生方法\nphp artisan make:controller TodoListController --resource --model=TodoList  如果不需要頁面的話　--resource 可以換成加上 --api 喔\nphp artisan make:controller API/TodoListController --api  用個model裝起來 php artisan make:model TodoList  會長出 ./app/TodoList.php\n在裡面寫你跟資料庫的互動等等(static function)\n然後你可以在controller裡面呼叫他們\nResource 打包你的資料 php artisan make:resource TodoList  :::info app/Providers/AppServiceProvider 裡面的 boot() 可以加上 use Illuminate\\Http\\Resources\\Json\\Resource; Resource::withoutWrapping(); 它會不包裝你的response :::\nCollection 打包你的資料們 php artisan make:resource TodoListCollection  來灌些假資料 factory製造出假的資料、資料型態, seeder把他們寫起來\nphp artisan make:seeder TodoListSeeder php artisan make:factory TodoListFactory  首先去DatabaseSeeder 的 run 裡面, 把你要跑的seeder註冊個\n$this-\u0026gt;call([ TodoListSeeder::class, //other seeder ]);  再來是目標的TodoListSeeder 會用到factory回傳資料, 到 TodoListFactory 設計 這樣它會回傳5筆 fake 資料到資料庫\n//call factory to fake data factory(App\\TodoList::class, 5)-\u0026gt;create();  執行 DatabaseSeeder 中被指定的 seeder 們\n./artisan db:seed   BLOG - 實作時間 (by Dagg) 建立Article的Model 為了建立存放文章的Model輸入指令: php artisan make:model 'Article' --migration 同時建立該model的migration\n管理Article的Model class Article extends Model { protected $table = 'articles'; // $fillable 為可以填入的table protected $fillable = [ 'content' ]; }  建立Migration文件中資料表的欄位格式  $table-\u0026gt;increment('_'); // 自動產生的key $table-\u0026gt;longText('_'); // 放置無限字元的欄位 例如:文章內容 $table-\u0026gt;string('_'); // 放置255字元內的字串欄位 $table-\u0026gt;softDeletes(); // 建立一個判別軟刪除的欄位 $table-\u0026gt;timestamps(); // 建立時間標記的欄位(會建立兩個欄位，一個放建立時間一個放更新時間)  調整完你要產生的欄位行別之後在終端機輸入: $ php artisan migrate\nController public function store(Request $request) // 建立一個store的函式 會接收Request { $article = $request-\u0026gt;input('article'); //把Request的input丟進去$article這個變數裡面 $show = new Article(); // 建立一個新的Article物件 $show-\u0026gt;content = $article; // 讓新建的Article物件轉成Request的input $show-\u0026gt;user_id = 1; // 紀錄user_id $show-\u0026gt;save(); // 把這個Article這個物件save return 'Hi'; // 測試用寫爽的 想不到吧 }  ","id":34,"section":"posts","summary":"新手入門 結構介紹 我們現在在 laravel v5.7 一起來看一下 laravel 專案的結構吧 app 大部份的網頁後端主要程式碼 也就是說他很重要 (Model)放在外面的大寫開頭們～ 例如","tags":["php","laravel"],"title":"筆記 laravel 真新手時間","uri":"https://blog.10oz.tw/20190123-a-new-in-laravel/","year":"2019"},{"content":"Step by Step 安裝指南 事前準備 HomeBrew 首先安裝 HomeBrew，他是 Mac 上的套件管理工具\n在終端機執行他： (裝過了可以跳過)\n/usr/bin/ruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026quot;  ＊ Docker 安裝 Docker， 以會需要他多多照顧\n不想登入可以直接點 下載連結 下載 .dmg 並安裝\n安裝 python3 用 brew 裝，已經裝好了，跳過\n安裝 docker-compose 就是把 docker 組隊，一次把一群不同 docker 給開起來的工具\npip3 install docker-compose  ＊ 安裝 PHP (7.1.3以上) brew install php@7.2  ＊ 下載 Composer composer 是 php 的套件管理工具，想像他跟 pip, npm 這些的傢伙是一樣的\n可以直接跑下面的指令，或是到下載頁面下載 php -r \u0026quot;copy('https://getcomposer.org/installer', 'composer-setup.php');\u0026quot; php -r \u0026quot;if (hash_file('sha384', 'composer-setup.php') === '93b544968e392c0362774670ac182b134cd3b3a09695e5dca5e53c3728f1a9f115f20b3b754bf9a1be329d521bdaa8b26ac6a13e9a62d6444cdb0dc8a1da0806156398a5cbe587c3f0fe57a54d8f5') { echo 'Installer verified'; } else { echo 'Installer corrupt'; unlink('composer-setup.php'); } echo PHP_EOL;\u0026quot; php composer-setup.php php -r \u0026quot;unlink('composer-setup.php');\u0026quot;  裝完後會多出一個 composer.phar，我們把它放到可使用指令區 sudo mkdir /usr/local/bin -p sudo mv composer.phar /usr/local/bin/composer  ＊ 安裝 NodeJS 來這邊安裝 https://nodejs.org/en/download/ 目前我使用的版本是 8.12 ，不過下載到 10版的應該也不會有問題啦 \u0026gt; \u0026lt;\n 下載 Laravel 框架 移動到要安裝的資料夾，例如： cd ~/project  利用 git 下載， 完成後會多一個 practice 資料夾 git clone https://github.com/laravel/laravel.git practice  安裝 Laravel 相依套件 移動到專案資料夾 cd practice  利用 composer 安裝 php 的相依套件 composer install  更新一下 js 套件 npm install  更改權限 sudo chmod -R 777 storage/ bootstrap/cache/  試試看能不能開服務啦～～～ php artisan serve  用你的瀏覽器開這個 http://127.0.0.1:8000\n敲棒der～～～ 開過後，更改權限2 sudo chmod -R 777 storage/   好像\u0026hellip;還缺了些東西？ 那我的資料庫呢？ 我們找 Laradock來幫我們吧!\n＊ 在 project 裡面安裝 laradock # cd ~/project/practice git submodule add https://github.com/Laradock/laradock.git  裝好之後, 我們複製一份 laravel 的設定檔 cp .env.example .env  產生 app key php artisan key:generate  然後修改一下 MySQL 連線的設定 # at ~/project/practice/.env # line 9 DB_CONNECTION=mysql DB_HOST=mysql DB_PORT=3306 DB_DATABASE=default DB_USERNAME=default DB_PASSWORD=secret  還有 laradock 的也是 cd laradock cp env-example .env  最後我們要小改一下，改變 laradock 存檔的位置 # line 14 DATA_PATH_HOST=~/.laradock/practice-data  下載 docker image docker pull xiao4011/laradock_mysql docker tag xiao4011/laradock_mysql:latest laradock_mysql:latest  看起來設定好了，跑跑看？ laradock 也可以幫你開很多不同的服務，這裡我們先開好我們需要用的\ndocker-compose up -d mysql phpmyadmin  試試看連線 回到外層，也就是 ~/project/practice\n執行一下這個指令\nphp artisan migrate  他幫你建了幾張 table 你就成功了\nBonus 找個視窗開啟服務 php artisan serve 執行一下這個指令，看看多了些什麼\nphp artisan make:auth  就自動幫你建好會員登入系統了，很方便ㄅ\n To Be Continue\u0026hellip; 下集待續\n","id":35,"section":"posts","summary":"Step by Step 安裝指南 事前準備 HomeBrew 首先安裝 HomeBrew，他是 Mac 上的套件管理工具 在終端機執行他： (裝過了可以跳過) /usr/bin/ruby -e \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\u0026quot; ＊ Docker 安裝 Docker， 以","tags":["php","laravel"],"title":"筆記 安裝 Laravel on MacOS","uri":"https://blog.10oz.tw/20190117-install-laravel-on-macos/","year":"2019"},{"content":"需求 讓 console log 可以正確顯示來源 ip 而不是被 web server 轉發的 ip\n實作修改 覆蓋掉 address_string 這個 function line:8 覆蓋掉 log function line:9\nimport logging # get werkzeug_logger werkzeug_logger = logging.getLogger('werkzeug') # Override the built-in werkzeug logging function in order to change the log line format. from werkzeug.serving import WSGIRequestHandler WSGIRequestHandler.address_string = lambda self: \\ self.headers.get('X-Forwarded-For') if self.headers.get('X-Forwarded-For') else self.client_address[0] WSGIRequestHandler.log = lambda self, type, message, *args: \\ getattr(werkzeug_logger, type)('%s %s' % (self.address_string(), message % args))  ","id":36,"section":"posts","summary":"需求 讓 console log 可以正確顯示來源 ip 而不是被 web server 轉發的 ip 實作修改 覆蓋掉 address_string 這個 function line:8 覆蓋掉 log function line:9 import logging # get werkzeug_logger werkzeug_logger = logging.getLogger('werkzeug') # Override the built-in werkzeug logging function in order to change the log line format. from werkzeug.serving import WSGIRequestHandler WSGIRequestHandler.address_string","tags":["python","flask"],"title":"筆記 自定義 flask 的 console log 之路","uri":"https://blog.10oz.tw/20181128-custom-flask-console-log/","year":"2018"},{"content":"問題描述 同時開太多連線啦\n環境 Ubuntu 16.04\n解決方法 https://blog.csdn.net/qq_23926575/article/details/76619827\n開啟這個檔案 sudo vim /etc/security/limits.conf\n在最底下新增兩行\n* soft nofile 10000 * hard nofile 10000  記得重開Server\n","id":37,"section":"posts","summary":"問題描述 同時開太多連線啦 環境 Ubuntu 16.04 解決方法 https://blog.csdn.net/qq_23926575/article/details/76619827 開啟這個檔案 sudo vim /etc/security/limits.conf 在最底下新增兩行 * soft nofile 10000 * hard nofile 10000 記得重開Server","tags":["python"],"title":"筆記 python: Error 24: too many open files","uri":"https://blog.10oz.tw/20181120-python-error24-too-many-open-files/","year":"2018"},{"content":"錯誤: 目標是成功執行它：\npip3 install mysqlclient  arios@AriosMac: pymysql_pool » pip3 install mysqlclient Collecting mysqlclient Using cached https://files.pythonhosted.org/packages/ec/fd/83329b9d3e14f7344d1cb31f128e6dbba70c5975c9e57896815dbb1988ad/mysqlclient-1.3.13.tar.gz Complete output from command python setup.py egg_info: /bin/sh: mysql_config: command not found Traceback (most recent call last): File \u0026quot;\u0026lt;string\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; File \u0026quot;/private/var/folders/xf/g7567kgs05vf5t8zfrnfh9th0000gn/T/pip-install-pqr5axvg/mysqlclient/setup.py\u0026quot;, line 18, in \u0026lt;module\u0026gt; metadata, options = get_config() File \u0026quot;/private/var/folders/xf/g7567kgs05vf5t8zfrnfh9th0000gn/T/pip-install-pqr5axvg/mysqlclient/setup_posix.py\u0026quot;, line 53, inget_config libs = mysql_config(\u0026quot;libs_r\u0026quot;) File \u0026quot;/private/var/folders/xf/g7567kgs05vf5t8zfrnfh9th0000gn/T/pip-install-pqr5axvg/mysqlclient/setup_posix.py\u0026quot;, line 28, inmysql_config raise EnvironmentError(\u0026quot;%s not found\u0026quot; % (mysql_config.path,)) OSError: mysql_config not found ---------------------------------------- Command \u0026quot;python setup.py egg_info\u0026quot; failed with error code 1 in /private/var/folders/xf/g7567kgs05vf5t8zfrnfh9th0000gn/T/pip-install-pqr5axvg/mysqlclient/  解決方法 for ubuntu 16 LTS：\napt install -y libmysqlclient-dev  for mac:\nbrew install mysql  ","id":38,"section":"posts","summary":"錯誤: 目標是成功執行它： pip3 install mysqlclient arios@AriosMac: pymysql_pool » pip3 install mysqlclient Collecting mysqlclient Using cached https://files.pythonhosted.org/packages/ec/fd/83329b9d3e14f7344d1cb31f128e6dbba70c5975c9e57896815dbb1988ad/mysqlclient-1.3.13.tar.gz Complete output from command python setup.py egg_info: /bin/sh: mysql_config: command not found Traceback (most recent call last): File \u0026quot;\u0026lt;string\u0026gt;\u0026quot;, line 1, in \u0026lt;module\u0026gt; File \u0026quot;/private/var/folders/xf/g7567kgs05vf5t8zfrnfh9th0000gn/T/pip-install-pqr5axvg/mysqlclient/setup.py\u0026quot;, line 18, in \u0026lt;module\u0026gt; metadata, options = get_config() File \u0026quot;/private/var/folders/xf/g7567kgs05vf5t8zfrnfh9th0000gn/T/pip-install-pqr5axvg/mysqlclient/setup_posix.py\u0026quot;, line 53, inget_config libs = mysql_config(\u0026quot;libs_r\u0026quot;) File \u0026quot;/private/var/folders/xf/g7567kgs05vf5t8zfrnfh9th0000gn/T/pip-install-pqr5axvg/mysqlclient/setup_posix.py\u0026quot;, line","tags":["python","mysql","mysqlclient"],"title":"筆記 mysqlclient 安裝, error: python setup.py egg_info ","uri":"https://blog.10oz.tw/20181117-install-mysqlclient/","year":"2018"},{"content":"問題 當你的函示庫底層使用 C語言 而不是純 python 編寫時 pylint 可能會無法正確的找到他，此問題可能出現在numpy或是本例的mysqlclient上\n解決方法 加入以下至白名單 $vim ~/.pylintrc\nextension-pkg-whitelist=MySQLdb  ","id":39,"section":"posts","summary":"問題 當你的函示庫底層使用 C語言 而不是純 python 編寫時 pylint 可能會無法正確的找到他，此問題可能出現在numpy或是本例的mysqlclient上 解決方法","tags":["python","vscode"],"title":"筆記 解決 VSCode 上 pylint 無法解析 c 函式庫的內容","uri":"https://blog.10oz.tw/20181108-run-pylint-clib-on-vscode/","year":"2018"}],"tags":[{"title":"argo","uri":"https://blog.10oz.tw/tags/argo/"},{"title":"artisan","uri":"https://blog.10oz.tw/tags/artisan/"},{"title":"blockchain","uri":"https://blog.10oz.tw/tags/blockchain/"},{"title":"buildx","uri":"https://blog.10oz.tw/tags/buildx/"},{"title":"casbin","uri":"https://blog.10oz.tw/tags/casbin/"},{"title":"cd","uri":"https://blog.10oz.tw/tags/cd/"},{"title":"chromedp","uri":"https://blog.10oz.tw/tags/chromedp/"},{"title":"chromium","uri":"https://blog.10oz.tw/tags/chromium/"},{"title":"de","uri":"https://blog.10oz.tw/tags/de/"},{"title":"di","uri":"https://blog.10oz.tw/tags/di/"},{"title":"docker","uri":"https://blog.10oz.tw/tags/docker/"},{"title":"elasticsearch","uri":"https://blog.10oz.tw/tags/elasticsearch/"},{"title":"eloquent","uri":"https://blog.10oz.tw/tags/eloquent/"},{"title":"es","uri":"https://blog.10oz.tw/tags/es/"},{"title":"ethereum","uri":"https://blog.10oz.tw/tags/ethereum/"},{"title":"flask","uri":"https://blog.10oz.tw/tags/flask/"},{"title":"geth","uri":"https://blog.10oz.tw/tags/geth/"},{"title":"gfw","uri":"https://blog.10oz.tw/tags/gfw/"},{"title":"git","uri":"https://blog.10oz.tw/tags/git/"},{"title":"gitlab","uri":"https://blog.10oz.tw/tags/gitlab/"},{"title":"golang","uri":"https://blog.10oz.tw/tags/golang/"},{"title":"golnag","uri":"https://blog.10oz.tw/tags/golnag/"},{"title":"gomod","uri":"https://blog.10oz.tw/tags/gomod/"},{"title":"gql","uri":"https://blog.10oz.tw/tags/gql/"},{"title":"graphql","uri":"https://blog.10oz.tw/tags/graphql/"},{"title":"helm","uri":"https://blog.10oz.tw/tags/helm/"},{"title":"homebrew","uri":"https://blog.10oz.tw/tags/homebrew/"},{"title":"hugo","uri":"https://blog.10oz.tw/tags/hugo/"},{"title":"ilm","uri":"https://blog.10oz.tw/tags/ilm/"},{"title":"index","uri":"https://blog.10oz.tw/tags/index/"},{"title":"istio","uri":"https://blog.10oz.tw/tags/istio/"},{"title":"json","uri":"https://blog.10oz.tw/tags/json/"},{"title":"jwt","uri":"https://blog.10oz.tw/tags/jwt/"},{"title":"keycloak","uri":"https://blog.10oz.tw/tags/keycloak/"},{"title":"kops","uri":"https://blog.10oz.tw/tags/kops/"},{"title":"kubernetes","uri":"https://blog.10oz.tw/tags/kubernetes/"},{"title":"laravel","uri":"https://blog.10oz.tw/tags/laravel/"},{"title":"linux","uri":"https://blog.10oz.tw/tags/linux/"},{"title":"log","uri":"https://blog.10oz.tw/tags/log/"},{"title":"mongodb","uri":"https://blog.10oz.tw/tags/mongodb/"},{"title":"multi-arch","uri":"https://blog.10oz.tw/tags/multi-arch/"},{"title":"mysql","uri":"https://blog.10oz.tw/tags/mysql/"},{"title":"mysqlclient","uri":"https://blog.10oz.tw/tags/mysqlclient/"},{"title":"oauth","uri":"https://blog.10oz.tw/tags/oauth/"},{"title":"orm","uri":"https://blog.10oz.tw/tags/orm/"},{"title":"passport","uri":"https://blog.10oz.tw/tags/passport/"},{"title":"php","uri":"https://blog.10oz.tw/tags/php/"},{"title":"pokemon","uri":"https://blog.10oz.tw/tags/pokemon/"},{"title":"pokesay","uri":"https://blog.10oz.tw/tags/pokesay/"},{"title":"pretty","uri":"https://blog.10oz.tw/tags/pretty/"},{"title":"python","uri":"https://blog.10oz.tw/tags/python/"},{"title":"ruby","uri":"https://blog.10oz.tw/tags/ruby/"},{"title":"service-mesh","uri":"https://blog.10oz.tw/tags/service-mesh/"},{"title":"subgroup","uri":"https://blog.10oz.tw/tags/subgroup/"},{"title":"terraform","uri":"https://blog.10oz.tw/tags/terraform/"},{"title":"test","uri":"https://blog.10oz.tw/tags/test/"},{"title":"vagrant","uri":"https://blog.10oz.tw/tags/vagrant/"},{"title":"vim","uri":"https://blog.10oz.tw/tags/vim/"},{"title":"vm","uri":"https://blog.10oz.tw/tags/vm/"},{"title":"vpn","uri":"https://blog.10oz.tw/tags/vpn/"},{"title":"vscode","uri":"https://blog.10oz.tw/tags/vscode/"},{"title":"windows","uri":"https://blog.10oz.tw/tags/windows/"},{"title":"wire","uri":"https://blog.10oz.tw/tags/wire/"},{"title":"wsl2","uri":"https://blog.10oz.tw/tags/wsl2/"}]}